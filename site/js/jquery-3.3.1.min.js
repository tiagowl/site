/ *! jQuery v3.3.1 | (c) Fundação JS e outros colaboradores | jquery.org/license * /
! function (e, t) {"use strict"; "objeto" == typeof module && "object" == typeof module.exports? module.exports = e.document? t (e,! 0): function (e) {if (! e.document) throw new Error ("jQuery requer uma janela com um documento"); retorne t (e)}: t (e)} (janela "undefined"! = typeof window?: this, function ( e, t) {"use strict"; var n = [], r = e.document, i = Object.getPrototypeOf, o = n.slice, a = n.concat, s = n.push, u = n. indexOf, l = {}, c = l.toString, f = l.hasOwnProperty, p = f.toString, d = p.call (Objeto), h = {}, g = função e (t) função {return " "== typeof t &&" número "! = tipo de t.nodeType}, y = função e (t) {retorno nulo! = t & t === t.janela}, v = {tipo:! 0, src:! 0, noModule:! 0}; função m (e, t, n) {var i, o = (t = t || r) .createElement ("script"); if (o.text = e, n) para (i em v) n [i] && (o [i] = n [i]); t.head.appendChild (o) .parentNode.função removeChild (o)} x (e) {retornar null == e? e + "": "objeto" == typeof e || "função" == typeof e? l [c.call (e)] || " objeto ": typeof e} var b =" 3.3.1 ", w = função (e, t) {return novo w.fn.init (e, t)}, T = / ^ [\ s \ uFEFF \ xA0] + | [\ s \ uFEFF \ xA0] + $ / g; w.fn = w.prototype = {jquery: "3.3.1", construtor: w, comprimento: 0, toArray: function () {retorno o.call (this)}, get: function (e) {return null == e? o.call (this): e <0? isto [e + this.length]: isto [e]}, pushStack: function (e) {var t = w.merge (this.constructor (), e); return t.prevObject = isto, t}, cada: function (e) {return w.each (isto, e)}, map: function (e ) {return this.pushStack (w.map (isso, função (t, n) {return e.call (t, n, t)}))}, fatia: function () {return this.pushStack (o.apply (this, arguments)}}, first: function () {retornar this.eq (0)}, last: function () {retornar this.eq (-1)}, eq: function (e) {var t = this comprimento, n = + e + (e <0? t: 0);return this.pushStack (n> = 0 && n <t? [isso [n]]: [])}, end: function () {retornar this.prevObject || this.constructor ()}, push: s, classificar: n .sort, splice: n.splice}, w.extend = w.fn.extend = function () {var e, t, n, r, i, o, a = argumentos [0] || {}, s = 1, u = arguments.length, l =! 1; for ("booleano" == tipoof a && (l = a, a = argumentos [s] || {}, s ++), "objeto" == tipoof a || g (a) || (a = {}), s === u && (a = isto, s -); s <u; s ++) if (nulo! = (e = argumentos [s])) para ( t em e) n = a [t], a! == (r = e [t]) && (l && r&& (w.isPlainObject (r) || (i = Array.isArray (r)))? (i? (i =! 1, o = n && Array.isArray (n)? n: []): o = n && w.isPlainObject (n) n: {}, a [t] = w.extend (l, o, r) ): void 0! == r && (a [t] = r)); return a}, w.extend ({expando: "jQuery" + ("3.3.1" + Math.random ()). replace (/ \ D / g, ""), isReady:! 0, erro: function (e) {lançar novo erro (e)}, noop: function () {},isPlainObject: function (e) {var t, n; return! (! e || "objeto objeto]"! == c.call (e)) && (! (t = i (e)) || "função "== typeof (n = f.call (t," construtor ") && t.constructor) && p.call (n) === d)}, isEmptyObject: function (e) {var t; para (t em e) return! 1; return! 0}, globalEval: function (e) {m (e)}, cada: function (e, t) {var n, r = 0; se (C (e)) {for (n = e.length; r <r; r ++) if (! 1 === t.call (e [r], r, e [r])) break} mais para (r em e) if (! 1 === t.call (e [r], r, e [r])) quebra; retorno e}, trim: função (e) {retorno nulo == e? "" :( e + ""). substitua (T, " ")}, makeArray: function (e, t) {var n = t || []; retorna nulo! = e && (C (Objeto (e))? w.merge (n," string "== typeof e? [e]: e): s.call (n, e)), n}, inArray: function (e, t, n) {retorno null == t? -1: u.call (t, e, n) }, mesclagem: function (e, t) {para (var n = + t.length, r = 0, i = e.length; r <r; r ++) e [i ++] = t [r]; retorno e. comprimento = i, e}, grep:função (e, t, n) {para (var r, i = [], o = 0, a = e.length, s =! n; o <a; o ++) (r =! t (e [o] , o)) == s && i.push (e [o]); return i}, map: function (e, t, n) {var r, i, o = 0, s = []; if (C e)) para (r = e.length; o <r; o ++) null! = (i = t (e [o], o, n)) &&s.push (i); else para (o em e) null ! = (i = t (e [o], o, n)) &&s.push (i); retorne a.apply ([], s)}, guid: 1, suporte: h}), "função" = = typeof Símbolo && (w.fn [Symbol.iterator] = n [Symbol.iterator]), w.each ("Número de Função da String Booleana Matriz Data RegExp Objeto Símbolo de Erro" .split (""), função (e, t) {l ["[objeto" + t + "]"] = t.toLowerCase ()}); função C (e) {var t = !! e && "comprimento" em e && e.length, n = x (e); ! g (e) &&! y (e) && ("array" === n || 0 === t || "número" == tipo de t && t> 0 && t-1 em e)} var E = função (e ) {var t, n, r, i, o, a, s, u, l, c, f, p, d, h, g, y, v,m, x, b = "sizzle" + 1 * nova data, w = e.document, T = 0, C = 0, E = ae (), k = ae (), S = ae (), D = função (e, t) {return e === t && (f =! 0), 0}, N = {} hasOwnProperty, A = [], j = p.ex., q = p., L = A. push, H = A.slice, O = função (e, t) {para (var n = 0, r = e.length; n <r; n ++) if (e [n] === t) retorna n; return-1}, P = "checked | selected | async | autofoco | autoplay | controls | defer | disabled | hidden | ismap | loop | múltiplo | aberto | readonly | obrigatório | scoped", M = "[\\ x20 \\ t \\ r \\ n \\ f] ", R =" (?: \\\\. | [\\ w-] | [^ \ 0 - \\ xa0]) + ", I =" \\ ["+ M +" * ("+ R +") (?: "+ M +" * ([* ^ $ |! ~]? =) "+ M +" * (?: '((?: \\\\. | [^ \\\\ '') *) '| \ "((?: \\\\. | [^ \\\\\"]) *) \ "| (" + R + ")) | "+ M +" * \\] ", W =" :( "+ R +") (?: \\ ((('((?: \\\\. | [^ \\\\']) *) '| \ "((?: \\\\. | [^ \\\\\"]) *) \ ") | ((?: \\\\. | [^ \\\\ () [\ \]] | "+ I +") *) |.*) \\) |) ", $ = new RegExp (M +" + "," g "), B = novo RegExp (" ^ "+ M +" + | ((?: ^ | [^ \\\\] ) ():? *) "+ M +" + $ "," g "), F = novo RegExp (" ^ "+ M +" *, "+ M +" * "), _ = novo RegExp ("^" + M + "* ([> + ~] |" + M + ")" + M + "*"), z = novo RegExp ("=" + M + "* ([^ \\] '\"] *?) "+ M +" * \\] "," g "), X = novo RegExp (W), U = novo RegExp (" ^ "+ R +" $ "), V = {ID: new RegExp (" ^ # ("+ R +") "), CLASS: new RegExp (" ^ \\. ("+ R +") "), TAG: new RegExp (" ^ ("+ R +" | [*]) "), ATTR: new RegExp ("^" + I), PSEUDO: novo RegExp ("^" + W), CHILD: new RegExp ("^ :( apenas | primeiro | último | nth | nth-last) - (filho | de -type) (?: \\ ("+ M +" * (par | ímpar | (([+ -] |) (\\ d *) n |) "+ M +" * (?: ([+ -] | ) "+ M +"* (\\ d +) |)) "+ M +" * \\) |) "," i "), bool: novo RegExp (" ^ (?: "+ P +") $ "," i "), needsContext : new RegExp ("^" + M + "* [> + ~] |: (par | ímpar | eq | gt | lt | nth | primeiro | último) (?: \\ (" + M + "* ((?: - \\ d)? \\ d *) "+ M +" * \\) |) (? = [^ -] | $) "," i ")}, G = / ^ (?: entrada | selecione | textarea | botão) $ / i, Y = / ^ h \ d $ / i, Q = / ^ [^ {] + \ {\ s * \ [nativo \ w /, J = / ^ (?: # ([ \ w -] +) | (\ w +) | \. ([\ w -] +)) $ /, K = / [+ ~] /, Z = novo RegExp ("\\\\ ([\\ da -f] {1,6} "+ M +"? | ("+ M +") |.) "," ig "), ee = função (e, t, n) {var r =" 0x "+ t- 65536; return r! == r || n? T: r <0? String.fromCharCode (r + 65536): String.fromCharCode (r >> 10 | 55296,1023 & r | 56320)}, te = / ([\ 0- \ x1f \ x7f] | ^ -? \ D) | ^ - $ | [^ \ 0- \ x1f \ x7f- \ uFFFF \ w -] / g, ne = função (e, t) {return t? "\ 0" === e? "\ Ufffd": e.slice (0, -1) + "\\" + e.charCodeAt (e.length-1).toString (16) + "": "\\" + e}, re = function () {p ()}, ie = me (função (e) {return! 0 === e.disabled && ("form" em e || "label" em e)}, {dir: "parentNode", próximo: "legend"}); try {L.apply (A = H.call (w.childNodes), w.childNodes), A [ w.childNodes.length] .nodeType} catch (e) {L = {aplicar: função A.length? (e, t) {q.apply (e, H.call (t))}: function (e, t ) {var n = e.length, r = 0; while (e [n ++] = t [r ++]); e.length = n-1}}} função oe (e, t, r, i) {var , s, l, c, f, h, v, m = t & t.ownerDocument, T = t? t.nodeType: 9; if (r = r || [], "string"! = tipo de e ||! e || 1! == T && 9! == T && 11! == T) return r; if (! I && ((t? T.ownerDocument || t: w)! == d && p (t), t = t || d , g)) {se (11! == T && (f = J.exec (e))) se (o = f [1]) {se (9 === T) {se (! (l = t. getElementById (o))) return r; if (l.id === o) retorna r.push (l), r} else if (m && (l = m.getElementById (o)) && x (t, l) && l.id === o) return r.push (l), r} sen {if (f [2]) return L.apply (r, t.getElementsByTagName (e)), r; if ((o = f [3]) && n.getElementsByClassName && t.getElementsByClassName) retornar L.apply (r, t.getElementsByClassName (o)), r} if (n.qsa &&! S [e + ""] && (! Y ||! Y.test ( e))) {if (1! == T) m = t, v = e; else if ("objeto"! == t.nodeName.toLowerCase ()) {(c = t.getAttribute ("id") c = c.replace (te, ne): t.setAttribute ("id", c = b), s = (h = a (e)). length; while (s -) h [s] = "#" + c + "" + ve (h [s]); v = h.join (","), m = K.test (e) && ge (t.parentNode) || t} se (v) tentar {return L.apply (r, m.querySelectorAll (v)), r} catch (e) {} finalmente {c === b && t.removeAttribute ("id")}}} return u (e.replace (B, "$ 1"), t, r, i)} função ae () {var e = []; função t (n, i) {retorno e.push (n + "")> r.cacheLength && delete t [e.shift ()], t [n + ""] = i} return t} função se (e) {retorno e [b] =! 0, e} função ue (e) {var t = d.createElement ("fieldset" try {return !! e (t)} catch (e) {return! 1} finalmente {t.parentNode && t.parentNode.removeChild (t), t = null}} função le (e, t) {var n = e.split ("|"), i = n.length; enquanto (i -) r.attrHandle [n [i]] = t} função ce (e, t) {var n = t && e, r = n && 1 = == e.nodeType && 1 === t.nodeType && e.sourceIndex-t.sourceIndex; if (r) return r; if (n) while (n = n.nextSibling) if (n === t) return-1; e? 1: -1} função fe (e) {função return (t) {return "input" === t.nodeName.toLowerCase () && t.type === e}} função pe (e) {função return (t) {var n = t.nodeName.toLowerCase (); return ("entrada" === n || "botão" === n) && t.type === e}} função de (e) {return function (t) {return "form" em t? t.parentNode &&! 1 === t.desativado? "label" em t? "label" em t.parentNode? t.parentNode.disabled === e: t.disabled === e: t.isDisabled === e || t.isDisabled! ==! e & ie (t) === e: t.disabled === e: "label" em t && t.disabled === e}} function ele (e) {return se (função (t) {return t = + t, se (função (n, r) {var i, o = e ([], n.length, t), a = o.length; while (a -) n [i = o [a]] && (n [i] =! (r [i] = n [i]))})})} função ge (e) {retorno e && "undefined"! = tipo de e.getElementsByTagName && e} n = oe.support = {}, o = oe.isXML = function (e) {var t = e && (e.ownerDocument || e) .documentElement; return !! t && "HTML"! == t.nodeName}, p = oe.setDocument = function (e) {var t, i, a = e? e.ownerDocument || e: w; return a! == d && 9 === a.nodeType && a.documentElement? (d = a, h = d.documentElement, g =! o ( d), w! == d && (i = d.defaultView) && i.top! == i && (i.addEventListener? i.addEventListener ("unload", re,! 1): i.attachEvent && i.attachEvent ("onunload", re)), n.attributes = ue (função (e) {return e.className = "i",! e.getAttribute ("className")}), n.getElementsByTagName = ue (função (e) {return e.appendChild (d.createComment ("")), e.getElementsByTagName ("*"). comprimento}), n.getElementsByClassName = Q.test (d.getElementsByClassName), n.getById = ue (função (e) {retorno h.appendChild (e) .id = b,! D.getElementsByName ||! D.getElementsByName (b) .length}) , n.getById? (r.filter.ID = função (e) {var t = e.replace (Z, ee); função de retorno (e) {return e.getAttribute ("id") === t}} , r.find.ID = função (e, t) {if ("indefinido"! = tipo de t.getElementById && g) {var n = t.getElementById (e); retorno n? [n]: []}}): (r.filter.ID = função (e) {var t = e. lugar (Z, ee); função de retorno (e) {var n = "indefinido"!= typeof e.getAttributeNode && e.getAttributeNode ("id"); return n && n.value === t}}, r.find.ID = função (e, t) {if ("indefinido"! = tipo de t.getElementById && g) { var n, r, i, o = t.getElementById (e); if (o) {se ((n = o.getAttributeNode ("id")) && n.value === e) return [o]; i = t.getElementsByName (e), r = 0; while (o = i [r ++]) if ((n = o.getAttributeNode ("id")) && n.value === e) retorno [o]} retorno [] }}), r.find.TAG = n.getElementsByTagName? function (e, t) {retorno "undefined"! = tipo de t.getElementsByTagName? t.getElementsByTagName (e): n.qsa? t.querySelectorAll (e): void 0}: function (e, t) {var n, r = [], i = 0, o = t.getElementsByTagName (e); if ("*" === e) {enquanto (n = o [i ++ ]) 1 === n.nodeType && r.push (n); retorno r} retorno o}, r.find.CLASS = n.getElementsByClassName && function (e, t) {se ("indefinido"! = Tipo de t.getElementsByClassName && g) retorna t.getElementsByClassName (e)}, v = [], y = [], (n.qsa = Q.test (d.querySelectorAll)) && (ue (função (e) {h.appendChild (e) .innerHTML = "<a id='"+b+"'> </a> <selecionar id = '" + b + "- \ r \\' msallowcapture = ''> <opção selecionada = ''> </ option> </ select> ", e.querySelectorAll (" [msallowcapture ^ = '] "). length && y.push (" [* ^ $] = "+ M +" * (?:' '| \ "\") ") , e.querySelectorAll ("[selecionado]"). length || y.push ("\\ [" + M + "* (?: valor |" + P + ")"), e.querySelectorAll ("[id ~ = "+ b +" -] "). length || y.push (" ~ = "), e.querySelectorAll (": marcado "). length || y.push (": checked "), e.querySelectorAll (" a # "+ b +" + * "). length || y.push (". #. + [+ ~]")}), ue (função (e) {e.innerHTML = "<a href='' disabled='disabled'> </a> <selecione desabilitado = 'desabilitado '> <option /> </ select> "; var t = d.createElement (" entrada "); t.setAttribute (" tipo "," oculto "), e.appendChild (t) .setAttribute (" nome ", "D"), e.querySelectorAll ("[nome = d]"). Length && y.push ("nome" + M + "* [* ^ $ |! ~]? ="), 2! == e.querySelectorAll ( ": ativado"). length && y.push (": ativado", ": disabled"), h.appendChild (e) .disabled =! 0,2! == e.querySelectorAll (": disabled"). length && y.push (": enabled", ": disabled"), e.querySelectorAll ("* ,:"), y.push (",. *:")})), (n.matchesSelector = Q.test (m = h.matches || h.webkitMatchesSelector || h.mozMatchesSelector || h.oMatchesSelector || h.msMatchesSelector)) && ue (função (e) {n.disconnectedMatch = m.call (e, "*"), m.call (e, "[s! = '']: x "), v.push ("! = ", W)}), y = y.length && new RegExp (y.join (" | ")), v = v.length && new RegExp (v.join (" | ") ), t = Q.test (h.compareDocumentPosition), x = t || Q.test (h.contains)? função (e, t) {var n = 9 === e.nodeType? e.documentElement: e , r = t && t.parentNode; return e === r ||! (! r || 1! == r.nodeType ||! (n.contains? n.contains (r): e.compareDocumentPosition && 16 & e.compareDocumentPosition (r) )))}: function (e, t) {se (t) while (t = t.parentNode) if (t === e) retornar! 0; retorno! 1}, D = t? função (e, t ) {if (e === t) return f =! 0,0; var r =! e.compareDocumentPosition-! t.compareDocumentPosition; return r || (1 & (r = (e.ownerDocument || e) == = (t.ownerDocument || t)? e.compareDocumentPosition (t): 1) ||! n.sortDetached && t.compareDocumentPosition (e) === r? e === d || e.ownerDocument === w && x (w, e)? - 1: t === d || t.ownerDocument === w && x (w , t)? 1: c? O (c, e) -O (c, t): 0: 4 & r? -1: 1)}: funï¿½o (e, t) {se (e === t) retorna f =! 0,0; var n, r = 0, i = e.parentNode, o = t.parentNode, a = [e], s = [t]; if (! I ||! O) return e == = d? -1: t === d? 1: i? -1: o? 1: c? O (c, e) -O (c, t): 0; se (i === o) retorno ce (e, t); n = e; while (n = n.parentNode) a.unshift (n); n = t; enquanto (n = n.parentNode) s.unshift (n); while (a [r ] === s [r]) r ++; return r? ce (a [r], s [r]): a [r] === w? -1: s [r] === w? 1: 0}, d): d}, oe.matches = função (e, t) {retorno oe (e, nulo, nulo, t)}, oe.matchesSelector = função (e, t) {if ((e.ownerDocument || e)! == d && p (e), t = t.replace (z, "= '$ 1']"), n.matchesSelector && g &&! S [t + ""] && (! v ||! v.test ( t)) && (! y ||! y.test (t))) try {var r = m.call (e, t); if (r || n.disconnectedMatch || e.document && 11! == e.document.nodeType) return r} catch (e) {} retorna oe (t, d, nulo, [e]). length> 0}, oe.contains = função (e, t) {return (e.ownerDocument || e)! == d && p (e), x (e, t)}, oe.attr = função (e, t) {(e.ownerDocument || e)! == d && p (e); var i = r. attrHandle [t.toLowerCase ()], o = i && N.call (r.attrHandle, t.toLowerCase ())? i (e, t,! g): void 0; retorno void 0! == o? o: n .atributes ||! g? e.getAttribute (t): (o = e.getAttributeNode (t)) && o.specified? o.value: null}, oe.escape = função (e) {return (e + "") .replace (te, ne)}, oe.error = função (e) {throw new Erro ("Erro de sintaxe, expressão não reconhecida:" + e)}, oe.uniqueSort = função (e) {var t, r = [ ], i = 0, o = 0; se (f =! n.detectDuplicates, c =! n.sortStable && e.slice (0), e.sort (D), f) {enquanto (t = e [o ++]) t === e [o] && (i = r.push (o)); enquanto (i -) e.splice (r [i], 1)} retorna c = nulo, e}, i = oe. getText = function (e) {var t, n = "", r = 0, o = e.nodeType;if (o) {if (1 === o || 9 === o || 11 === o) {if ("string" == typeof e.textContent) retornar e.textContent; para (e = e .firstChild; e; e = e.nextSibling) n + = i (e)} sen se (3 === o || 4 === o) retornar e.nodeValue} else while (t = e [r ++]) n + = i (t); return n}, (r = oe.selectors = {cacheLength: 50, createPseudo: se, correspondência: V, attrHandle: {}, find: {}, relative: {">": {dir: "parentNode", primeiro:! 0}, "": {dir: "parentNode"}, "+": {dir: "previousSibling", primeiro:! 0}, "~": {dir: "previousSibling"}} , preFilter: {ATTR: função (e) {return e [1] = e [1] .replace (Z, ee), e [3] = (e [3] || e [4] || e [5 ] || ""). substitua (Z, ee), "~ =" === e [2] && (e [3] = "" + e [3] + ""), e.slice (0, 4)}, CHILD: function (e) {return e [1] = e [1] .toLowerCase (), "nth" === e [1] .slice (0,3)? (E [3] | | oe.error (e [0]), e [4] = + (e [4] e [5] + (e [6] || 1): 2 * ("par"=== e [3] || "ímpar" === e [3])), e [5] = + (e [7] + e [8] || "ímpar" === e [3] )): e [3] && oe.error (e [0]), e}, PSEUDO: function (e) {var t, n =! e [6] && e [2]; retorno V.CHILD.test (e [0])? Null: (e [3]? E [2] = e [4] || e [5] || "": n && X.test (n) && (t = a (n,! 0) ) && (t = n.indexOf (")", n.length-t) -n.length) && (e [0] = e [0] .slice (0, t), e [2] = n. slice (0, t)), e.slice (0,3))}}, filtro: {TAG: função (e) {var t = e.replace (Z, ee) .toLowerCase (); retorno "*" === e? function () {return! 0}: function (e) {return e.nodeName && e.nodeName.toLowerCase () === t}}, CLASSE: função (e) {var t = E [e + " "]; return t || (t = new RegExp (" (^ | "+ M +") "+ e +" ("+ M +" | $) ")) && E (e, função (e) {return t.test ("string" == typeof e.className && e.className || "undefined"! = tipo de e.getAttribute && e.getAttribute ("class") || "")}}}, ATTR: function (e, t, n) {função return (r) {var i = oe.attr (r, e); retorno null == i? "! =" === t:! t || (i + = "", "=" === t? i === n: "! =" === t? i! == n: "^ = "=== t? n && 0 === i.indexOf (n):" * = "=== t? n && i.indexOf (n)> - 1:" $ = "=== t? n && i.slice ( -n.length) === n: "~ =" === t? ("" + i.replace ($, "") + "") .indexOf (n)> - 1: "| =" = == t && (i === n || i.slice (0, n.length + 1) === n + "-"))}}, CHILD: função (e, t, n, r, i) { var o = "nth"! == e.slice (0,3), a = "ultimo"! == e.slice (-4), s = "do tipo" === t; retorno 1 == = r && 0 === Função i (e) {return !! e.parentNode}: função (t, n, u) {var l, c, f, p, d, h, g = o! == a? "nextSibling": "previousSibling", y = t.parentNode, v = s && t.nodeName.toLowerCase (), m =! u &&! s, x =! 1; if (y) {se (o) {enquanto (g) {p = t; enquanto (p = p [g]) se (s? p. nodeName.toLowerCase () === v: 1 === p.nodeType) return! 1; h = g = "somente" === e &&! h && "nextSibling"} return! 0} if (h = [a? y.firstChild: y.lastChild], a && m) {x = (d = (l = (c = (f = (p = y) [b] || (p [b] = {})) [p.uniqueID ] || (f [p.uniqueID] = {})) [e] || []) [0] === T && l [1]) && l [2], p = d && y.childNodes [d]; p = ++ d && p && p [g] || (x = d = 0) || h.pop ()) if (1 === p.nodeType && ++ x && p === t) {c [e] = [T , d, x]; break}} else if (m && (x = d = (l = (c = (f = (p = t) [b] || (p [b] = {})) [p. uniqueID] || (f [p.uniqueID] = {})) [e] || []) [0] === T && l [1]) ,! 1 === x) enquanto (p = ++ d && p && p [g] || (x = d = 0) || h.pop ()) if ((s? p.nodeName.toLowerCase () === v: 1 === p.nodeType) && ++ x && ( m && ((c = (f = p [b] || (p [b] = {})) [p.uniqueID] || (f [p.uniqueID] = {})) [e] = [T, x]),p === t)) quebra; retorno (x- = i) === r || x% r == 0 && x / r> = 0}}}, PSEUDO: função (e, t) {var n, i = r.pseudos [e] || r.setFilters [e.toLowerCase ()] || oe.error ("pseudo não suportado:" + e); retorno i [b]? i (t): i.length> 1 (n = [e, e, "", t], r.setFilters.hasOwnProperty (e.toLowerCase ())? se (função (e, n) {var r, o = i (e, t), um = o.length; while (a -) e [r = O (e, o [a])] =! (n [r] = o [a])}): função (e) {retorno i (e , 0, n)}): i}}, pseudos: {não: se (função (e) {var t = [], n = [], r = s (e.replace (B, "$ 1")) ; return r [b]? se (função (e, t, n, i) {var o, a = r (e, nulo, i, []), s = e.length; while (s -) ( o = a [s]) && (e [s] =! (t [s] = o))}): função (e, i, o) {retorno t [0] = e, r (t, nulo, o, n), t [0] = nulo,! n.pop ()}}), tem: se (função (e) {função de retorno (t) {retorno oe (e, t) .length> 0}} ), contém: se (função (e) {return e = e.replace (Z, ee), função (t) {return (t.textContent || t.innerText || i (t)). indexOf (e) > -1}}), idioma:se (função (e) {return U.test (e || "") || oe.error ("idioma não suportado:" + e), e = e.replace (Z, ee) .toLowerCase (), function ( t) {var n; do {if (n = g? t.lang: t.getAttribute ("xml: lang") || t.getAttribute ("lang")) return (n = n.toLowerCase ()) = == e || 0 === n.indexOf (e + "-")} enquanto ((t = t.parentNode) && 1 === t.nodeType); retorno! 1}}), target: function (t) {var n = e.location && e.location.hash; return n && n.slice (1) === t.id}, raiz: função (e) {retorno e === h}, foco: função (e) {retorno e === d.activeElement && (! d.hasFocus || d.hasFocus ()) && !! (e.type || e.href || ~ e.tabIndex)}, ativado: de (! 1), desativado : de (! 0), verificado: function (e) {var t = e.nodeName.toLowerCase (); retorna "input" === t && !! e.checked || "option" === t && !! e .selected}, selecionado: function (e) {return e.parentNode && e.parentNode.selectedIndex ,!0 === e.selected}, empty: function (e) {para (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType <6) return! 1; return! 0}, pai : function (e) {return! r.pseudos.empty (e)}, cabeçalho: function (e) {retornar Y.test (e.nodeName)}, entrada: function (e) {return G.test (e. nodeName)}, botão: function (e) {var t = e.nodeName.toLowerCase (); retorna "input" === t && "button" === e.type || "button" === t}, text: function (e) {var t; return "input" === e.nodeName.toLowerCase () && "text" === e.type && (null == (t = e.getAttribute ("tipo")) || "texto" === t.toLowerCase ())}, primeiro: ele (function () {return [0]}), last: ele (function (e, t) {return [t-1]}) , eq: he (função (e, t, n) {retorno [n <0? n + t: n]}), mesmo: ele (função (e, t) {para (var n = 0; n <t ; n + = 2) e.push (n); retorno e}), ímpar: he (função (e, t) {para (var n = 1; n <t; n + = 2) e.push (n); return e}), lt: ele (função (e, t,n) {para (var r = n <0 n + t: n; - r> = 0;) e.push (r); retorno e}), gt: he (função (e, t, n) {para (var r = n <0 n + t: n; ++ r <t;) e.push (r); return e})}}). pseudos.nth = r.pseudos.eq; t em {rádio:! 0, caixa de seleção:! 0, arquivo:! 0, senha:! 0, imagem:! 0}) r.pseudos [t] = fe (t); para (t em {enviar:! 0 , reset:! 0}) r.pseudos [t] = pe (t); função ye () {} ye.prototype = r.filters = r.pseudos, r.setFilters = novo você, a = oe.tokenize = função (e, t) {var n, i, o, a, s, u, l, c = k [e + ""]; se (c) retornar t? 0: c.slice (0); s = e , u = [], l = r.preFilter; enquanto (s) {n &&! (i = F.exec (s)) || (i && (s = s.slice (i [0] .comprimento) || s ), u.push (o = [])), n =! 1, (i = _. exec (s)) && (n = i.shift (), o.push ({valor: n, tipo: i [0] .replace (B, "")}), s = s.slice (n.length)); para (a em r.filter)! (I = V [a] .exec (s)) || l [a] &&! (i = l [a] (i)) || (n = i.shift (), o.push ({valor: n, tipo: a, corresponde a: i}), s = s .slice (n.length)); if (! n) break} retorna t? s.length: s? oe.error (e):k (e, u) .segmento (0)}; função ve (e) {para (var t = 0, n = e.length, r = ""; t <n; t ++) r + = e [t]. valor; retorno r} função me (e, t, n) {var r = t.dir, i = t.next, o = i || r, a = n && "parentNode" === o, s = C ++; return t.first? function (t, n, i) {while (t = t [r]) if (1 === t.nodeType || a) return e (t, n, i); retorno! 1} : função (t, n, u) {var l, c, f, p = [T, s]; se (u) {enquanto (t = t [r]) if ((1 === t.nodeType | | a) && e (t, n, u)) return! 0} else while (t = t [r]) if (1 === t.nodeType || a) if (f = t [b] || ( t [b] = {}), c = f [t.uniqueID] || (f [t.uniqueID] = {}), i && i === t.nodeName.toLowerCase ()) t = t [r] | | else; se {(l = c [o]) && l [0] === T && l [1] === s) return p [2] = l [2]; se (c [o] = p , p [2] = e (t, n, u)) retorno! 0} return! 1}} função xe (e) {retorno e.length> 1? função (t, n, r) {var i = e .length; while (i -) if (! e [i] (t, n, r)) retorna! 1; return! 0}: e [0]} função be (e, t, n) {para ( var r = 0, i = t.length; r <i; r ++) oe (e, t [r], n); função de retorno n} nós (e, t, n,r, i) {para (var o, a = [], s = 0, u = e.length, l = null! = t; s <u; s ++) (o = e [s]) && (n &&! n (o, r, i) || (a.push (o), l && t.push (s))); return a} função Te (e, t, n, r, i, o) {retorno r &&! r [b] && (r = Te (r)), i &&! i [b] && (i = Te (i, o)), se (função (o, a, s, u) {var l, c, f , p = [], d = [], h = comprimento, g = o || ser (t || "*", s.nodeType? [s]: s, []), y =! e | |! o && t? g: nós (g, p, e, s, u), v = n? i || (o? e: h || r)? []: a: y; if (n && n (y, v, s, u), r) {l = nós (v, d), r (l, [], s, u), c = l.length; enquanto (c -) (f = l [c] ) && (v [d [c]] =! (y [d [c]] = f))} se (o) {se (i || e) {se (i) {l = [], c = v.length; while (c -) (f = v [c]) && l.push (y [c] = f); i (nulo, v = [], l, u)} c = v.length; enquanto (c -) (f = v [c]) && (l = i? O (o, f): p [c])> - 1 && (o [l] =! (a [l] = f) }}} else v = we (v === a? v.splice (h, v.length): v), i? i (nulo, a, v, u): L.apply (a, v)} )} function Ce (e) {para (var t, n, i, o = e.length, a = r.relative [e [0] .type], s = a || r.relative [""], u = a? 1: 0, c = me (função (e) {retorno e === t}, s,! 0), f = me (função (e) {retorno O (t , e)> - 1}, s,! 0), p = [função (e, n, r) {var i =! a && (r || n! == l) || ((t = n). nodeType? c (e, n, r): f (e, n, r)); return t = null, i}]; u <o; u ++) if (n = r.relativo [e [u] .type ]) p = [me (xe (p), n)]; senão {if ((n = r.filter [e [u] .tipo] .apply (null, e [u] .matches)) [b] ) {para (i = ++ u; i <o; i ++) if (r.relativo [e [i] .tipo]) quebra; retorno Te (u> 1 && xe (p), u> 1 && ve (e.slice ( 0, u-1) .concat ({valor: "" === e [u-2]. Tipo? "*": ""})). Substituir (B, "$ 1"), n, u <i && Ce (e.slice (u, i)), i <o && Ce (e = e.slice (i)), i <o && ve (e)}} p.push (n)} retorno xe (p)} função Ee (e , t) {var n = t.length> 0, i = e.length> 0, o = função (o, a, s, u, c) {var f, h, y, v = 0, m = " 0 ", x = o && [], b = [], w = l, C = o || i && r.find.TAG (" * ", c), E = T + = nulo == w? 1: Matemática.random () || .1, k = C.length; para (c && (l = a === d || a || c); m! == k && nulo! = (f = C [m]); m ++ ) {if (i & f) {h = 0, a || f.ownerDocument === d || (p (f), s =! g); while (y = e [h ++]) if (y (f, a || d, s)) {e.p (f); quebra , n && m! == v) {h = 0; enquanto (y = t [h ++]) y (x, b, a, s); se (o) {se (v> 0) enquanto (m -) x [m] || b [m] || (b [m] = j.call (u)); b = nós (b)} L.apply (u, b), c &&! o && b.length> 0 && v + t .length> 1 && oe.uniqueSort (u)} retornar c && (T = E, l = w), x}; retornar n? se (o): o} retornar s = oe.compile = function (e, t) {var n, r = [], i = [], o = S [e + ""]; se (! o) {t || (t = a (e)), n = t.length; enquanto (n-- ) (o = Ce (t [n])) [b] r.push (o): i.push (o); (o = S (e, Ee (i, r))). selector = e} return o}, u = oe.select = função (e, t, n, i) {var o, u, l, c, f, p = "função" == typeof e && e, d =! i && a (e = p .selector || e);if (n = n || [], 1 === d.length) {se ((u = d [0] = d [0] .segmento (0)). comprimento> 2 && "ID" === ( l = u [0]) tipo && 9 === t.nodeType && g && r.relative [u [1] .type]) {if (! (t = (r.find.ID (l.matches [0] .replace (Z , ee), t) || []) [0])) return n; p && (t = t.parentNode), e = e.slice (u.shift (). value.length)} o = V.needsContext .test (e)? 0: u.length; while (o -) {se (l = u [o], r.relativo [c = l.type]) quebra; if ((f = r.find [) c]) && (i = f (l.matches [0] .replace (Z, ee), K.test (u [0] .tipo) && ge (t.parentNode) || t))) {se (u .splice (o, 1),! (e = i.length && ve (u))) retorno L.apply (n, i), n; quebra}}} return (p || s (e, d)) (i , t,! g, n,! t || K.test (e) && ge (t.parentNode) || t), n}, n.sortStable = b.split (""). sort (D) .join ("") === b, n.detectDuplicates =! f, p (), n.sortDetached = ue (função (e) {return 1 & e.compareDocumentPosition (d.createElement ("fieldset"))}),ue (function (e) {return e.innerHTML = "<a href='#'> </a>", "#" === e.firstChild.getAttribute ("href")}) || le (" tipo | href | altura | largura ", função (e, t, n) {if (! n) return e.getAttribute (t," tipo "=== t.toLowerCase ()? 1: 2)}), n .attributos && ue (função (e) {return e.innerHTML = "<input />", e.firstChild.setAttribute ("valor", ""), "" === e.firstChild.getAttribute ("valor")} ) || le ("valor", função (e, t, n) {if (! n && "input" === e.nodeName.toLowerCase ()) return e.defaultValue}), ue (função (e) { return null == e.getAttribute ("disabled")}) || le (P, funç˜ao (e, t, n) {var r; if (! n) return! 0 === e [t] t. toLowerCase () :( r = e.getAttributeNode (t)) && r.specified? r.value: null}), oe} (e); w.find = E, w.expr = E.seletores, w.expr [ ":"] = w.expr.pseudos, w.uniqueSort = w.unique = E.uniqueSort, w.text = E.getText, w.isXMLDoc = E.isXML, w.contains = Contém, w.escapeSelector = E.escape; var k = função (e, t, n) {var r = [], i = void 0! == n; while ((e = e [t]) && 9! == e.nodeType) if (1 === e.nodeType ) {if (i & w (e) .é (n)) quebra; r.push (e)} retorna r}, S = função (e, t) {para (var n = []; e; e = e. nextSibling) 1 === e.nodeType && e! == t && n.push (e); return n}, D = w.expr.match.needsContext; function N (e, t) {return e.nodeName && e.nodeName.toLowerCase ( ) === t.toLowerCase ()} var A = / ^ <([az] [^ \ / \ 0>: \ x20 \ t \ r \ n \ f] *) [\ x20 \ t \ r \ n \ f] * \ /?> (?: <\ / \ 1> |) $ / i; função j (e, t, n) {retorno g (t)? w.grep (e, função (e, r ) {return !! t.call (e, r, e)! == n}): t.nodeType? w.grep (e, função (e) {return e === t! == n}): "string"! = typeof t? w.grep (e, função (e) {return u.call (t, e)> - 1! == n}): w.filter (t, e, n)} w .filter = função (e, t, n) {var r = t [0];return n && (e = ": not (" + e + ")"), 1 === t.length && 1 === r.nodeType? w.find.matchesSelector (r, e)? [r]: []: w .find.matches (e, w.grep (t, função (e) {return 1 === e.nodeType}))}, w.fn.extend ({encontrar: function (e) {var t, n, r = this.length, i = this; if ("string"! = typeof e) retorna this.pushStack (w (e) .filter (function () {para (t = 0; t <r; t ++) if ( w.contains (i [t], this)) return! 0})); for (n = this.pushStack ([]), t = 0; t <r; t ++) w.find (e, i [t ], n); retorno r> 1? w.uniqueSort (n): n}, filtro: função (e) {return this.pushStack (j (isto, e || [] ,! 1))}, não: function (e) {return this.pushStack (j (isto, e || [] ,! 0))}, é: function (e) {return !! j (isto, "string" == typeof e && D.test ( e)? w (e): e || [] ,! 1) Comprimento}}; var q, L = / ^ (?: \ s * (<[\ w \ W] +>) [^> ] * | # ([\ w -] +)) $ /; (w.fn.init = função (e, t, n) {var i, o; if (! e) retorna isto; se (n = n || q, "string" == typeof e) {if (! (i = "<"=== e [0] &&"> "=== e [e.length-1] && e.length> = 3? [null, e, null]: L.exec (e)) ||! i [ 1] && t) return! T || t.jquery? (T || n) .find (e): este.construtor (t) .find (e); if (i [1]) {if (t = t Exemplo de w? t [0]: t, w.merge (isso, w.parseHTML (i [1], t && t.nodeType? t.ownerDocument || t: r,! 0)), A.test (i [1 ]) && w.isPlainObject (t)) para (i em t) g (isto [i])? isto [i] (t [i]): isto.attr (i, t [i]); devolva isto} retorno (o = r.getElementById (i [2])) && (this [0] = o, this.length = 1), isso} return e.nodeType? (this [0] = e, this.length = 1, isto): g (e)? void 0! == n.ready? n.ready (e): e (w): w.makeArray (e, isto)}). prototype = w.fn, q = w ( r); var H = / ^ (?: pais | prev (?: Até | Todos)) /, O = {filhos:! 0, conteúdo:! 0, próximo:! 0, prev:! 0}; w. fn.extend ({tem: function (e) {var t = w (e, isto), n = t.length; retorna this.filter (function () {para (var e = 0; e <n; e ++) if (w.contains (isto, t [e])) return! 0})}, mais próximo: function (e,t) {var n, r = 0, i = este.length, o = [], a = "string"! = typeof e && w (e); if (! D.test (e)) para (; r <i ; r ++) para (n = este [r]; n && n! == t; n = n.parentNode) if (n.nodeType <11 && (a? a.index (n)> - 1: 1 === n. nodeType && w.find.matchesSelector (n, e))) {o.push (n); break} retornar this.pushStack (o.length> 1? w.uniqueSort (o): o)}, índice: function (e) {return e? "string" == tipo de e? u.call (w (e), este [0]): u.call (isto, e.jquery? e [0]: e): this [0] && este [0] .parentNode? This.first (). PrevAll (). Length: -1}, add: function (e, t) {retornar this.pushStack (w.uniqueSort (w.merge (this.get (), w (e, t))))}, addBack: function (e) {retornar this.add (null == e? this.prevObject: this.prevObject.filter (e))}}); função P (e, t) {enquanto ((e = e [t]) && 1! == e.nodeType); return e} w.each ({pai: função (e) {var t = e.parentNode; retorno t && 11! == t .nodeType? t: null}, pais:function (e) {retornar k (e, "parentNode")}, parentsUntil: function (e, t, n) {retornar k (e, "parentNode", n)}, próximo: function (e) {return P ( e, "nextSibling")}, prev: function (e) {retornar P (e, "previousSibling")}, nextAll: function (e) {returnk (e, "nextSibling")}, prevAll: function (e) {return k (e, "previousSibling")}, nextUntil: função (e, t, n) {retorno k (e, "nextSibling", n)}, prevUntil: função (e, t, n) {retorno k ( e, "previousSibling", n)}, irmãos: function (e) {return S ((e.parentNode || {}). firstChild, e)}, filhos: function (e) {return S (e.firstChild) }, contents: function (e) {retornar N (e, "iframe")? e.contentDocument: (N (e, "modelo") && (e = e.content || e), w.merge ([] , e.childNodes))}}, function (e, t) {w.fn [e] = função (n, r) {var i = w.map (isto, t, n); retorno "Até"! = e.slice (-5) && (r = n), r e& "string" == typeof r && (i = w.filter (r, i)), este.length> 1 && (O [e] || w.uniqueSort (i), H.test (e) && i.reverse ( )), this.pushStack (i)}}); var M = / [^ \ x20 \ t \ r \ n \ f] + / g; função R (e) {var t = {}; return w.each (e.match (M) || [], function (e, n) {t [n] =! 0}), t} w.Callbacks = função (e) {e = "string" == typeof e? R (e): w.extend ({}, e); var t, n, r, i, o = [], a = [], s = -1, u = função () {para (i = i || e.once, r = t =! 0; a.length; s = -1) {n = a.shift (); enquanto (++ s <o.length)! 1 === o [s] .apply (n [0], n [1]) && e.stopOnFalse && (s = o.length, n =! 1)} e.memory || (n =! 1), t =! 1, i && (o = n? []: "")}, l = {adicionar: function () {return o && (n &&! t && (s = o.length-1, a.push (n)), função t (n) {w. each (n, função (n, r) {g (r)? e.unique && l.has (r) || o.push (r): r && r.length && "string"! == x (r) & t (r) })} (argumentos), n &&! t &&u ()), this}, remove: function () {return w.each (argumentos, função (e, t) {var n; enquanto ((n = w.inArray (t, o, n))> - 1 ) o.splice (n, 1), n ​​<= s && s -}), isto}, tem: function (e) {return e? w.inArray (e, o)> - 1: o.length> 0} vazio: function () {return o && (o = []), isto}, desabilite: function () {return i = a = [], o = n = "", este}, desabilitado: function () {return ! o}, lock: function () {retorno i = a = [], n || t || (o = n = ""), isto}, bloqueado: function () {return !! i}, fireWith: function (e, n) {return i || (n = [e, (n = n || []). slice? n.slice (): n], a.push (n), t || u ( )}, this}, fire: function () {retornar l.fireWith (this, arguments), this}, disparado: function () {return !! r}}; return l}; função I (e) {return e } função W (e) {lançar e} função $ (e, t, n, r) {var i; try {e & g (i = e.promise)? i.call (e) .done (t) .fail ( n): e & g (i = e.then)? i.call (e, t, n): t.apply (void 0, [e] .slice (r))} catch (e) {n.apply (vazio 0, [e])}} w.extend ({Deferred: function (t) {var n = [["notificar", "progresso", w.Callbacks ("memória"), w.Callbacks ("memória"), 2], ["resolver", " done ", w.Callbacks (" once memory "), w.Callbacks (" once memory "), 0," resolvido "], [" reject "," fail ", w.Callbacks (" once memory "), w .Callbacks ("once memory"), 1, "rejected"]], r = "pendente", i = {estado: function () {return r}, sempre: function () {return o.done (argumentos). fail (argumentos), this}, "catch": function (e) {retorno i.then (null, e)}, pipe: function () {var e = argumentos; return w.Deferred (function (t) {w cada um deles (n, função (n, r) {var i = g (e [r [4]]) && e [r [4]]; o [r [1]] (função () {var e = i & i. aplica (isto, argumentos); e & g (e.promise)? e.promise () .progresso (t.notify) .done (t.resolve) .fail (t.reject):t [r [0] + "com"] (isto, i? [e]: argumentos)})}), e = null}). promise ()}, então: function (t, r, i) {var o = 0; função a (t, n, r, i) {função de retorno () {var s = isto, u = argumentos, l = função () {var e, l; if (! (t <o)) {if ((e = r.apply (s, u)) === n.promise ()) lançar novo TypeError ("Auto-resolução de subida"); l = e && ("object" == typeof e || " função "== typeof e) && e.then, g (l)? i? l.call (e, a (o, n, eu, i), a (o, n, W, i)) :( o ++, l.call (e, um (o, n, eu, i), um (o, n, W, i), um (o, n, eu, n.notificarCom))) :( r! == I && ( s = void 0, u = [e]), (i || n.resolveWith) (s, u)}}}, c = i? l: function () {try {l ()} captura (e) { w.Deferred.exceptionHook && w.Deferred.exceptionHook (e, c.stackTrace), t + 1> = o && (r! == W && (s = void 0, u = [e]), n.rejectWith (s, u) )}}; t? c () :( w.Deferred.getStackHook && (c.stackTrace = w.Deferred.getStackHook ()), e.setTimeout (c))}} return w.Deferred (função (e) {n [0] [3]add (a (0, e, g (i)? i: eu, e.notificarCom)), n [1] [3] .add (a (0, e, g (t)? t: I)), n [2] [3] .add (a (0, e, g (r)? r: W))}). promise ()}, promessa: function (e) {return null! = e? w.extend (e, i): i}}, o = {}; retorno w.each (n, função (e, t) {var a = t [2], s = t [5]; i [t [1] ] = a.add, s && a.add (function () {r = s}, n [3-e] [2] .disable, n [3-e] [3] .disable, n [0] [2] .lock, n [0] [3] .lock), a.add (t [3] .fire), o [t [0]] = função () {retorno o [t [0] + "Com"] (this === o? void 0: this, arguments), isto}, o [t [0] + "Com"] = a.fireCom}), i.promise (o), t && t.call (o, o ), o}, quando: function (e) {var t = argumentos.length, n = t, r = Matriz (n), i = o.call (argumentos), a = w.Deferred (), s = função (e) {função de retorno (n) {r [e] = isto, i [e] = argumentos.length> 1? o.call (argumentos): n, - t || a.resolveWith (r, i) }}; if (t <= 1 && ($ (e, a.done (s (n)). resolver, a.reject,! t), "pendente" === a.state () || g (i [n] && i [n]. then))) return a.then ();while (n -) $ (i [n], s (n), a.reject); retorne a.promise ()}}); var B = / ^ (Eval | Internal | Range | Referência | Sintaxe | Tipo | URI) Erro $ /; w.Deferred.exceptionHook = função (t, n) {e.console && e.console.warn && t && B.test (t.name) && e.console.warn ("exceção jQuery.Deferred:" + t. message, t.stack, n)}, w.readyException = function (t) {e.setTimeout (function () {lance t})}; var F = w.Deferred (); w.fn.ready = function ( e) {return F.then (e) ["catch"] (função (e) {w.readyException (e)}), isto}, w.extend ({isReady:! 1, readyWait: 1, pronto: function (e) {(! 0 === e? - w.readyWait: w.isReady) || (w.isReady =! 0,! 0! == e && - w.readyWait> 0 || F.resolveWith (r, [w]))}}), w.ready.then = F. then; function _ () {r.removeEventListener ("DOMContentLoaded", _), e.removeEventListener ("load", _), w .ready ()} "complete" === r.readyState || "carregamento"! == r.readyState &&! r.documentElement.doScroll? e.setTimeout (w.ready) :( r.addEventListener ("DOMContentLoaded", _), e.addEventListener ("carregar", _)); var z = função (e, t, n, r, i, o, a) {var s = 0, u = e.length, l = null == n; if ("objeto" === x (n)) {i =! 0; s em n) z (e, t, s, n [s], 0, o, a)} else if (vazio 0! == r && (i =! 0, g (r) || (a =! 0), l && (a? (T.call (e, r), t = null): (l = t, t = função (e, t, n) {retorno l.call (w (e), n) })), t)) para (; s <u; s ++) t (e [s], n, a? r: r.call (e [s], s, t (e [s], n)) ; i return return return return return return return return return return return return return return return return return return return return return return return return return return return return,,,,,,,,,, [[[[[[[[[[[ g; função V (e, t) {retorno t.toUpperCase ()} função G (e) {retorno e.replace (X, "ms -"). substituir (U, V)} var Y = função (e) {return 1 === e.nodeType || 9 === e.nodeType ||! + e.nodeType}; função Q () {this.expando = w.expando + Q.uid ++} Q.uid = 1, Q.prototype = {cache: função (e) {var t = e [this.expando]; retorno t || (t = {}, Y (e) && (e.nodeType? e [this.expando] = t: Object.defineProperty (e, this.expando, {valor: t, configurável:! 0}))), t}, conjunto: function (e, t, n) {var r, i = this.cache (e); if ("string" == typeof t) i [G (t)] = n; else para (r em t) i [G (r)] = t [r] ; return i}, get: function (e, t) {return void 0 === t? this.cache (e): e [this.expando] && e [this.expando] [G (t)]}, acesso : function (e, t, n) {retornar void 0 === t || t && "string" == typeof t && void 0 === n? this.get (e, t) :( this.set (e, t , n), void 0! == n? n: t)}, remove: function (e, t) {var n, r = e [this.expando]; if (void 0! == r) {if ( void 0! == t) {n = (t = Array.isArray (t)? t.map (G): (t = G (t)) em r? [t]: t.match (M) || []). length; while (n -) deletar r [t [n]]} (void 0 === t || w.isEmptyObject (r)) && (e.nodeType? e [this.expando] = void 0: delete e [this.expando])}}, hasData: function (e) {var t = e [this.expando]; return void 0! == t &&! w.isEmptyObject (t)}}; var J = novo Q, K = novo Q, Z = / ^ (?:\ {[\ w \ W] * \} | [[\ w \ W] * \]) $ /, ee = / [AZ] / g; função te (e) {retorno "verdadeiro" === e || "false"! == e && ("null" === e? null: e === + e + ""? + e: Z.test (e)? JSON.parse (e): e)} function ne (e, t, n) {var r; if (void 0 === n && 1 === e.nodeType) if (r = "dados -" + t.replace (ee, "- $ &"). toLowerCase (), "string" == typeof (n = e.getAttribute (r))) {try {n = te (n)} captura (e) {} K.set (e, t, n)} mais n = void 0; return n} w.extend ({hasData: function (e) {retorno K.hasData (e) || J.hasData (e)}, dados: function (e, t, n) {retorno K.access (e, t, n)}, removeData: função (e, t) {K.remove (e, t)}, _ dados: function (e, t, n) {retorno J.access (e, t, n) }, _ removeData: function (e, t) {J.remove (e, t)}}), w.fn.extend ({dados: function (e, t) {var n, r, i, o = isto [ 0], a = o && o.attributes; if (void 0 === e) {if (this.length && (i = K.get (o), 1 === o.nodeType &&! J.get (o, "hasDataAttrs "))) {n = a.length; while (n -) a [n] && 0 === (r = a [n] .name) .indexOf ("dados -") && (r = G (r. slice (5)), ne (o, r, i [r])); jset (o, "hasDataAttrs",! 0)} return i} return "objeto" == typeof e? this.each (function () {K.set (isto, e)}): z (isto, função (t) {var n; se (o && void 0 === t) {if (void 0! == (n = K.get ( o, e))) return n; if (void 0! == (n = ne (o, e))) return n} else this.each (function () {K.set (isto, e, t)} )}, null, t, arguments.length> 1, nulo,! 0)}, removeData: function (e) {retornar this.each (function () {K.remove (this, e)})}}), w.extend ({fila: function (e, t, n) {var r; if (e) retorna t = (t || "fx") + "fila", r = J.get (e, t), n && (! r || Array.isArray (n)? r = J.access (e, t, w.makeArray (n)): r.push (n)), r || []}, dequeue: function ( e, t) {t = t || "fx"; var n = w.queue (e, t), r = n.length, i = n.shift (), o = w._queueHooks (e, t) , a = function () {w.dequeue (e, t)}; "inprogress"=== i && (i = n.shift (), r -), i && ("fx" === t && n.unshift ("inprogress"), delete o.stop, i.call (e, a, o) R, && o && o.empty.fire ()}, _ queueHooks: function (e, t) {var n = t + "queueHooks"; retorno J.get (e, n) || J.access (e, n, {vazio : w.Callbacks ("once memory"). adicione (function () {J.remove (e, [t + "fila", n])})})}}), w.fn.extend ({fila: função (e, t) {var n = 2; retorna "string"! = tipo e && (t = e, e = "fx", n -), arguments.length <n? w.queue (isto [0], e): void 0 === t? isto: this.each (function () {var n = w.queue (isto, e, t); w._queueHooks (isto, e), "fx" === e && "inprogress"! == n [0] && w.dequeue (isto, e)})}, dequeue: função (e) {retornar this.each (function () {w.dequeue (this, e)})}, clearQueue: function (e) {retornar this.queue (e || "fx", [])}, promessa: function (e, t) {var n, r = 1, i = w.Deferred (), o = isto, a = this.length, s = função () {- r || i.resolveWith (o, [o])}; "string"! = Typeof e && (t = e, e = void 0), e = e || "fx"; while (a -) (n = J.get (o [a], e + "queueHooks")) && n.empty && (r ++, n.empty.add ( s)); return s (), i.promise (t)}}); var re = / [+ -]? (?: \ d * \. |) \ d + (?: [eE] [+ -] ? \ d + |) /. source, ie = new RegExp ("^ (?: ([+ -]) = |) (" + re + ") ([az%] *) $", "i"), oe = ["Top", "Right", "Bottom", "Left"], ae = função (e, t) {return "nenhum" === (e = t || e) .style.display || " "=== e.style.display && w.contains (e.ownerDocument, e) &&" nenhum "=== w.css (e," display ")}, se = function (e, t, n, r) { var i, o, a = {}; para (o em t) a [o] = e.style [o], e.style [o] = t [o]; i = n.apply (e, r | | []); para (o em t) e.style [o] = a [o]; retorno i}; função ue (e, t, n, r) {var i, o, a = 20,s = r? function () {retorno r.cur ()}: function () {retorno w.css (e, t, "")}, u = s (), l = n && n [3] || (w .cssNumber [t]? "": "px"), c = (w.cssNumber [t] || "px"! == l && + u) && ie.exec (w.css (e, t)); (c & c [3]! == l) {u / = 2, l = l || c [3], c = + u || 1; enquanto (a -) w.style (e, t, c + l), (1-o) * (1- (o = s () / u || .5)) <= 0 && (a = 0), c / = o; c * = 2, w.style (e , t, c + l), n = n || []} return n && (c = + c || + u || 0, i = n [1]? c + (n [1] +1) * n [ 2]: + n [2], r && (r.unit = l, r.start = c, r.end = i)), i} var le = {}; função ce (e) {var t, n = e.ownerDocument, r = e.nodeName, i = le [r]; return i || (t = n.body.appendChild (n.createElement (r)), i = w.css (t, "display") , t.parentNode.removeChild (t), "nenhum" === i && (i = "bloco"), le [r] = i, i)} função fe (e, t) {para (var n, r, i = [], o = 0, a = e.length, o <a; o ++) (r = e [o]). estilo && (n = r.style.display, t? ("nenhum" === n && (i [o] = J.get (r, "display") || nulo, i [o] || (r.style.display = "")), "" === r.style.display && ae ( r) && (i [o] = ce (r))): "nenhum"! == n && (i [o] = "nenhum", J.set (r, "display", n))); o = 0; o <a; o ++) null! = i [o] && (e [o] .style.display = i [o]); return e} w.fn.extend ({show: function () { return fe (isso,! 0)}, hide: function () {return fe (isso)}, toggle: function (e) {return "booleano" == typeof e? e? this.show (): this.hide (): this.each (function () {ae (this)? w (this) .show (): w (this) .hide ()})}}; var pe = / ^ (?: checkbox | rádio $ / i, de = / <([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] +) / i, ele = / ^ $ | ^ module $ | \ / (? : java | ecma) script / i, ge = {opção: [1, "<selecionar vários = 'vários'>", "</ select>"], thead: [1, "<table>", "</ tabela> "], col: [2," <table> <colgroup>"," </ colgroup> </ table> "], tr: [2," <tabela> <tbody> "," </ tbody> </ table> "], td: [3," <tabela> < tbody> <tr> "," </ tr> </ tbody> </ table> "], _ padrão: [0," "," "]}; ge.optgroup = ge.option, ge.tbody = ge. tfoot = ge.colgroup = ge.caption = ge.thead, ge.th = ge.td; função ye (e, t) {var n; retorno n = "indefinido"! = tipo de e.getElementsByTagName? e.getElementsByTagName ( t || "*"): "indefinido"! = typeof e.querySelectorAll? e.querySelectorAll (t || "*"): [], void 0 === t || t && N (e, t)? w. funç˜ao ([e], n): n} funç˜ao ve (e, t) {para (var n = 0, r = e.length; n <r; n ++) J.set (e [n], "globalEval" , | t || J.get (t [n], "globalEval"))} var me = / <| & #? \ w +; /; função xe (e, t, n, r, i) {para ( var o, a, s, u, l, c, f = t.createDocumentFragment (),p = [], d = 0, h = e.length; d <h; d ++) if ((o = e [d]) || 0 === o) if ("objeto" === x (o )) w.merge (p, o.nodeType? [o]: o); senão se (me.test (o)) {a = a || f.appendChild (t.createElement ("div")), s = (de.exec (o) || ["", ""]) [1] .toLowerCase (), u = ge [s] || ge._default, a.innerHTML = u [1] + w.htmlPrefilter (o) + u [2], c = u [0]; enquanto (c -) a = a.lastChild; w.merge (p, a.childNodes), (a = f.firstChild) .textContent = " "} else p.push (t.createTextNode (o)); f.textContent =" ", d = 0; enquanto (o = p [d ++]) if (r && w.inArray (o, r)> - 1) i && i .push (o); caso contrário, (l = w.contains (o.ownerDocument, o), a = ye (f.appendChild (o), "script"), l && ve (a), n) {c = 0; while (o = a [c ++]) he.test (o.type || "") && n.push (o)} retorna f}! function () {var e = r.createDocumentFragment (). appendChild (r.createElement ("div")), t = r.createElement ("input"); t.setAttribute ("type", "radio"), t.setAttribute ("verificado", "verificado"), t.setAttribute ("nome", "t"), e.appendChild (t), h.checkClone = e. cloneNode (! 0) .cloneNode (! 0) .lastChild.checked, e.innerHTML = "<textarea> x </ textarea>", h.noCloneChecked = !! e.cloneNode (! 0) .lastChild.defaultValue} ( ); var be = r.documentElement, nós = / ^ chave /, Te = / ^ (?: mouse | ponteiro | contextmenu | arrastar | soltar) | clique em /, Ce = / ^ ([^.] *) (? : \. (. +) |) /; função Ee () {return! 0} função ke () {return! 1} função Se () {try {return r.activeElement} captura (e) {}} função De (e, t, n, r, i, o) {var a, s; if ("objeto" == typeof t) {"string"! = tipo de n && (r = r || n, n = void 0) para (s em t) De (e, s, n, r, t [s], o); retorne e} se (null == r && null == i? (i = n, r = n = void 0) : null == i && ("string" == tipoof n? (i = r, r = void 0) :( i = r, r = n, n = void 0)) ,! 1 === i) i = ke;else if (! i) return e; retorno 1 === o && (a = i, (i = função (e) {retorno w (). off (e), a.apply (isto, argumentos)}). = a.guid || (a.guid = w.guid ++)), e.each (function () {w.event.add (isso, t, i, r, n)})} w.event = {global : {}, adicione: function (e, t, n, r, i) {var o, a, s, u, l, c, f, p, d, h, g, y = j. ; if (y) {n.handler && (n = (o = n) .handler, i = o.selector), i && w.find.matchesSelector (ser, i), n.guid || (n.guid = w. guid ++), (u = y.eventos) || (u = y.eventos = {}), (a = y.handle) || (a = y.handle = função (t) {retorno "indefinido"! typeof w && w.event.triggered! == t.type? w.event.dispatch.apply (e, argumentos): void 0}), l = (t = (t || ""). correspondência (M) || [""]]. length; while (l -) d = g = (s = Ce.exec (t [l]) || []) [1], h = (s [2] || "" ) .split ("."). sort (), d && (f = w.event.special [d] || {}, d = (i? f.delegateType: f.bindType) || d, f = w .event.special [d] || {}, c = w.extend ({tipo: d, origType: g, dados: r,manipulador: n, guid: n.guid, seletor: i, needsContext: i && w.expr.match.needsContext.test (i), espaço de nomes: h.join (".")}, o), (p = u [d ]) || ((p = u [d] = []). delegateCount = 0, f.setup &&! 1! == f.setup.call (e, r, h, a) || e.addEventListener && e.addEventListener (d, a)), f.add && (f.add.call (e, c), c.handler.guid || (c.handler.guid = n.guid)), i? p.splice (p. delegateCount ++, 0, c): p.push (c), w.event.global [d] =! 0)}}, remova: function (e, t, n, r, i) {var o, a, s , u, l, c, f, p, d, h, g, y = J. tem os dados (e) && J.get (e); if (y && (u = y.eventos)) {l = (t = ( t || ""). match (M) || [""]). length; while (l -) se (s = Ce.exec (t [l]) || [], d = g = s [1], h = (s [2] || ""). Split ("."). Sort (), d) {f = w.evento.special [d] || {}, p = u [ d = (r? f.delegateType: f.bindType) || d] || [], s = s [2] && new RegExp ("(^ | \\.)" + h.join ("\\. ( ?:. * \\. |) ") +" (\\. | $) "), a = o = p.length;while (o -) c = p [o],! i && g! == c.origType || n && n.guid! == c.guid || s &&! s.test (c.namespace) || r && r! == c.selector && ("**"! == r ||! selector) || (p.splice (o, 1), c.selector && p.delegateCount -, f.remove && f.remove.call (e, c )); a &&! p.length && (f.teardown &&! 1! == f.teardown.call (e, h, y.handle) || w.removeEvent (e, d, y.handle), delete u [d ])} mais para (d in u) w.event.remove (e, d + t [l], n, r,! 0); w.isEmptyObject (u) && J.remove (e, "manipular eventos") }}, dispatch: function (e) {var = w.event.fix (e), n, r, i, o, a, s, u = novo Array (arguments.length), l = (J.get (isto, "eventos") || {}) [t.type] || [], c = w.event.special [t.type] || {}; para (u [0] = t, n = 1; n <argumentos.length; n ++) u [n] = argumentos [n]; if (t.delegateTarget = isto,! C.preDispatch ||! 1! == c.preDispatch.call (isto, t)) {s = w.event.handlers.call (isto, t, l), n = 0;while ((o = s [n ++]) &&! t.isPropagationStopped ()) {t.currentTarget = o.elem, r = 0; enquanto ((a = o.handlers [r ++]) &&! t.isImmediatePropagationStopped () t.rnamespace &&! t.rnamespace.test (a.namespace) || (t.handleObj = a, t.data = a.data, void 0! == (i = ((w.event.special [a. origType] || {}). handle || a.handler) .apply (o.elem, u)) &&! 1 === (t.result = i) && (t.preventDefault (), t.stopPropagation ( )))} return c.postDispatch && c.postDispatch.call (this, t), t.result}}, manipuladores: function (e, t) {var n, r, i, o, a, s = [], u = t.delegateCount, l = e.target; if (u && l.nodeType &&! ("click" === e.type && e.button> = 1)) para (; l! == this; l = l.parentNode || isto) if (1 === l.nodeType && ("click"! == e.type ||! 0! == l.disabled)) {for (o = [], a = {}, n = 0; n <u; n ++) void 0 === a [i = (r = t [n]). seletor + ""] && (a [i] = r.needsContext? w (i, isso) .index (l) >-1: w.find (i, isto, null, [l]). Length), a [i] && o.push (r); o.length && s.push ({elem: l, handlers: o})} l = isso, u <t.length && s.push ({elem: l, manipuladores: t.slice (u)}), s}, addProp: function (e, t) {Object.defineProperty (w.Event.prototype, e, {enumerável:! 0, configurável:! 0, get: g (t)? function () {if (this.originalEvent) retorna t (this.originalEvent)}: function () {if (this.originalEvent) return this.originalEvent [e]}, set: function (t) {Object.defineProperty (isto, e, {enumerável:! 0, configurável:! 0, gravável:! 0, valor: t})}})}, correção : function (e) {return e [w.expando]? e: novo w.Event (e)}, especial: {load: {noBubble:! 0}, foco: {trigger: function () {if (isso! == Se () && this.focus) retorna this.focus (),! 1}, delegateType: "focusin"}, blur: {trigger: function () {se (this === Se () && this.blur) retorna this.blur () ,! 1}, delegateType: "focusout"}, clique em: {trigger:function () {if ("checkbox" === this.type && this.click && N (this, "input")) retornar this.click (),! 1}, _ default: function (e) {retornar N (e.target, "a")}}, beforeunload: {postDispatch: function (e) {void 0! == e.result && e.originalEvent && (e.originalEvent.returnValue = e.result)}}}}, w.removeEvent = function (e , t, n) {e.removeEventListener && e.removeEventListener (t, n)}, w.Evento = function (e, t) {if (! (esta instância de w.Event)) return new w.Event (e, t) ; e && e.type? (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented || void 0 === e.defaultPrevented &&! 1 === e.returnValue? Ee: ke, this.target = e.target && 3 === e.target.nodeType? e.target.parentNode: e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget): this.type = e, t && w .extend (this, t), this.timeStamp = e && e.timeStamp || Date.now (), this [w.expando] =! 0}, w.Event.prototype = {construtor: w.Event, isDefaultPrevented: ke, isPropagationStopped: ke, isImmediatePropagationStopped: ke, isSimulated:! 1, preventDefault: function () {var e = this.originalEvent; this.isDefaultPrevented = Ee, e &&! This.isSimulated && e.preventDefault ()}, stopPropagation: function () {var e = this.originalEvent; this.isPropagationStopped = Ee , e & !, this.isSimulated && e.stopPropagation ()}, stopImmediatePropagation: function () {var e = this.originalEvent; this.isImmediatePropagationStopped = Ee, e &&! this.isSimulated && e.stopImmediatePropagation (), this.stopPropagation ()}}, w .each ({altKey:! 0, bolhas:! 0, cancelável:! 0, changedTouches:! 0, ctrlKey:! 0, detalhe:! 0, eventPhase:! 0, metaKey:! 0, páginaX:! 0, páginaY :! 0, shiftKey:! 0, vista:! 0, "char":! 0, charCode:! 0, chave:! 0, keyCode:! 0, botão:! 0,botões:! 0, clientX:! 0, clientY: 0, offsetX:! 0, offsetY:! 0, pointerId:! 0, pointerType:! 0, screenX:! 0, screenY:! 0, targetTouches:! 0, toElement:! 0, toca:! 0, que: function (e) {var t = e.button; return null == e.which && we.test (e.type)? null! = e.charCode? e.charCode: e.keyCode:! e.which && void 0! == t && Te.test (e.type)? 1 & t? 1: 2 & t? 3: 4 & t? 2: 0: e.which}}, w.event.addProp), w. each ({mouseenter: "mouseover", mouseeleave: "mouseout", ponteiro: "pointerover", pointerleave: "pointerout"}, função (e, t) {w.event.special [e] = {delegateType: t, bindType : t, identificador: function (e) {var n, r = isso, i = e.relatedTarget, o = e.handleObj; retorno i && (i === r || w.contains (r, i)) || (e.type = o.origType, n = o.handler.apply (isto, argumentos), e.type = t), n}}}), w.fn.extend ({on: function (e, t, n, r) {return De (isto, e, t, n, r)}, um: função (e, t, n, r) {return De (isto, e, t,n, r, 1)}, fora: função (E, T, N) {var r, i; if (e && e.preventDefault && e.handleObj) retorno r = e.handleObj, w (e.delegateTarget) .off (r. ? namespace r.origType + + r.namespace " ": r.origType, r.selector, r.handler), isto, se (" objeto" == typeof e) {for (i em e) this.off (i , t, e [i]; return this} return! 1! == t && "function"! = tipo de t || (n = t, t = void 0),! 1 === n && (n = ke) , this.each (function () {w.event.remove (isto, e, n, t)})}}); var Ne = / <(área ?! | br | col | embed | h | img | entrada | link | meta | param) (([az] [^ \ / \ 0> \ x20 \ t \ r \ n \ f] *) [^>] *) \ /> / gi, Ae = / <script | <estilo | <link / i, je = / verificado \ s * (?: [^ =] | = \ s * .checked.) / i, qe = / ^ \ s * <! (?: \ [CDATA \ [| -) | (?: \] \] | -)> \ s * $ / g; function Le (e, t) {retornar N (e, "table") && N (11! == t. nodeType? t: t.firstChild, "tr")? w (e) .children ("tbody") [0] || e: e} function Ele (e) {return e.type = (null! == e.getAttribute ("type")) + "/" + e.type, e} função Oe (e) {return "true /" === (e.type || "") .slice (0,5)? e.type = e.type.slice (5): e.removeAttribute ("tipo"), e} função Pe (e, t) {var n, r, i, o, a , s, u, l; if (1 === t.nodeType) {se (J.hasData (e) && (o = J. acesso (e), a = J.set (t, o), l = o.events)) {delete a.handle, a.events = {}; para (i em l) para (n = 0, r = l [i] .comprimento; n <r; n ++) w.event.add (t, i, l [i] [n])} K.hasData (e) && (s = K.acesso (e), u = w.extend ({}, s), K.set (t, u )}} function Me (e, t) {var n = t.nodeName.toLowerCase (); "entrada" === n && pe.test (e.type)? t.checked = e.checked: "entrada"! == n && "textarea"! == n || (t.defaultValue = e.defaultValue)} função Re (e, t, n, r) {t = a.apply ([], t); var i, o , s, u, l, c, f = 0, p = e.length, d = p-1, y = t [0], v = g (y); se (v || p> 1 && "string" == typeof y &&! h.checkClone && je.test (y)) return e.each (função (i) {var = e.eq (i); v && (t [0] = y.call (this, i, o.html ())), Re (o, t, n, r)}); if (p && (i = xe (t, e [0] proprietárioDocumento,! 1, e, r), o = i.firstChild, 1 === i. childNodes.length && (i = o), o || r)) {para (u = (s = w.map (ye (i, "script"), He)). comprimento; f <p; f ++) l = i, f! == d && (l = w.clone (l,! 0,! 0), u && w.merge (s, ye (l, "script"))), n.call (e [f], l , if (u) para (c = s [s.length-1] .ownerDocument, w.map (s, Oe), f = 0; f <u; f ++) l = s [f], ele .test (l.type || "") &&! J.access (l, "globalEval") && w.contains (c, l) && (l.src && "módulo"! == (l.type || "" ) .toLowerCase ()? w._evalUrl && w._evalUrl (l.src): m (l.textContent.replace (qe, ""), c, l))} return e} função Ie (e, t, n) { para (var r, i = t? w.filter (t, e): e, o = 0; null! = (r = i [o]); o ++) n || 1! == r.nodeType || W.cleanData (ye (r)), r.parentNode && (n && w.contains (r.ownerDocument, r) && ve (ye (r, "script")), r.parentNode.removeChild (r)); return e} w.extend ({htmlPrefilter: function (e) {retornar e.replace (Ne, "<$ 1> </ $ 2>")}, clone: ​​function (e, t, n) {var r, i, o, a, s = e.cloneNode (! 0), u = w.contains (e.ownerDocument, e); if (! (h.noCloneChecked || 1! == e.nodeType && 11! == e.nodeType || w.isXMLDoc (e ))) para (a = ye (s), r = 0, i = (o = ye (e)). comprimento; r ++) Eu (o [r], a [r]); t) se (n) para (o = o || ye (e), a = a || ye (s), r = 0, i = o.length; r <i; r ++) Pe (o [r] , a [r]); else Pe (e, s); return (a = ye (s, "script")). length> 0 && ve (a,! u && ye (e, "script")), s}, cleanData : function (e) {para (var t, n, r, i = w.event.special, o = 0; void 0! == (n = e [o]); o ++) if (Y (n)) {if (t = n [J.expando]) {if (t.eventos) para (r em t.eventos) i [r]? w.event.remove (n, r): w.removeEvent (n, r t.handle) n [J.expando] = void 0} n [K.expando] && (n [K.expando] = void 0)}}}), w.fn.extend ({separar: função (e) {return Ie (isto, e, ! 0)}, remove: function (e) {return Ie (isto, e)}, texto: function (e) {retorno z (isto, função (e) {return void 0 === e? W.text ( this): this.empty (). each (function () {1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || (this.textContent = e)})}, null, e , arguments.length)}, acrescentar: function () {return Re (isso, argumentos, função (e) {1! == this.nodeType && 11! == this.nodeType && 9! == this.nodeType || Le (isso, e) .appendChild (e)})}, prefixo: function () {return Re (isto, argumentos, função (e) {if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {var t = Le (isto, e); t.insertBefore (e, t.firstChild)}})}, antes de: function () {return Re (isto, argumentos, função (e) {this.parentNode && this.parentNode.insertBefore (e, this)})} depois de:function () {return Re (isto, argumentos, função (e) {this.parentNode && this.parentNode.insertBefore (e, this.nextSibling)})}, vazio: function () {para (var e, t = 0; null ! = (e = this [t]); t ++) 1 === e.nodeType && (w.cleanData (você (e,! 1)), e.textContent = ""); retorne isto}, clone: ​​function ( e, t) {return e = null! = e & e, t = null == t? e: t, this.map (function () {retorno w.clone (isto, e, t)})}, html: function (e) {return z (isto, função (e) {var t = isto [0] || {}, n = 0, r = este.length; if (vazio 0 === e && 1 === t.nodeType ) return t.innerHTML; if ("string" == typeof e &&! Ae.test (e) &&! ge [(de.exec (e) || ["", ""]) [1] .toLowerCase () ]) {e = w.htmlPrefilter (e); tente {para (; n <r; n ++) 1 === (t = isto [n] || {}). nodeType && (w.cleanData (ye (t, ! 1)), t.innerHTML = e); t = 0} catch (e) {}} e & this.empty (). Append (e)}, null, e, argumentos.length)}, substituaCom:function () {var e = []; return Re (isto, argumentos, função (t) {var n = this.parentNode; w.inArray (isto, e) <0 && (w.cleanData (ye (this)), n && n.replaceChild (t, this))}, e)}}), w.each ({appendTo: "append", prependTo: "prepend", insertBefore: "antes", insertAfter: "after", replaceAll: "replaceWith "}, função (e, t) {w.fn [e] = função (e) {para (var n, r = [], i = w (e), o = i.length-1, a = 0 ; a <= o; a ++) n = a === o? this: this.clone (! 0), w (i [a]) [t] (n), s.apply (r, n.get ( )) return this.pushStack (r)}}); var Nós = new RegExp ("^ (" + re + ") (! px) [az%] + $", "i"), $ e = function (t) {var n = t.ownerDocument.defaultView; return n && n.opener || (n = e), n.getComputedStyle (t)}, Be = new RegExp (oe.join ("|"), "i" ) ;! function () {função t () {if (c) {l.style.cssText = "posição: absoluta; esquerda: -11111px; largura: 60px; margem-topo:1px; padding: 0; border: 0 ", c.style.cssText =" posição: relativo; display: block; tamanho da caixa: border-box; overflow: scroll; margem: auto; borda: 1px; preenchimento: 1px; largura: 60%; topo: 1% ", be.appendChild (l) .appendChild (c); var t = e.getComputedStyle (c); i =" 1% "! == t.top, u = 12 = == n (t.marginLeft), c.style.right = "60%", s = 36 === n (t.right), o = 36 === n (t.width), c.style. position = "absolute", a = 36 === c.offsetWidth || "absolute", be.removeChild (l), c = null}} função n (e) {return Math.round (parseFloat (e))} var i, o, a, s, u, l = r.createElement ("div"), c = r.createElement ("div"); c.style && (c.style.backgroundClip = "content-box", c .cloneNode (! 0) .style.backgroundClip = "", h.clearCloneStyle = "caixa de conteúdo" === c.style.backgroundClip, w.extend (h, {boxSizingReliable: function () {retorno t (), o}, pixelBoxStyles:function () {retorno t (), s}, pixelPosition: function () {retorno t (), i}, trustedMarginLeft: function () {retorno t (), u}, scrollboxSize: function () {retorno t () , a}}))} (); função Fe (e, t, n) {var r, i, o, a, s = e.style; retorno (n = n || $ e (e)) && ( ""! == (a = n.getPropertyValue (t) || n [t]) || w.contains (e.ownerDocument, e) || (a = w.style (e, t)) ,! h .pixelBoxStyles () && We.test (a) && Be.test (t) && (r = s.width, i = s.minWidth, o = s.maxWidth, s.minWidth = s.maxWidth = s.width = a, a = n.width, s.width = r, s.minWidth = i, s.maxWidth = o)), void 0! == a? a + "": a} função _e (e, t) {return {get : function () {if (! e ()) return (this.get = t) .apply (isto, argumentos); delete this.get}}} var ze = / ^ (nenhum | tabela (?! - c [ ea]). +) /, Xe = / ^ - /, Ue = {posição: "absoluto", visibilidade: "oculto", exibição: "bloco"}, ve = {letterSpacing: "0", fontWeight: " 400 "}, Ge = [" Webkit ","Moz", "ms"], Ye = r.createElement ("div"). Style; função Qe (e) {if (e em Ye) return e; var t = e [0] .toUpperCase () + e .slice (1), n ​​= Ge.length; enquanto (n -) if ((e = Ge [n] + t) em Ye) retorna e} função Je (e) {var t = w.cssProps [e ]; return t || (t = w.cssProps [e] = Qe (e) || e), t} função Ke (e, t, n) {var r = ie.exec (t); retorno r? Math.max (0, r [2] - (n || 0)) + (r [3] || "px"): t} função Ze (e, t, n, r, i, o) {var a = "largura" === t? 1: 0, s = 0, u = 0; se (n === (r? "borda": "conteúdo")) retorno 0; para (; a <4; a + = 2) "margin" === n && (u + = w.css (e, n + oe [a], 0, i)), r? ("conteudo" === n && (u- = w. css (e, "preenchimento" + oe [a], 0, i)), "margem"! == n && (u- = w.css (e, "borda" + oe [a] + "Largura") ! 0, i))): (u + = w.css (e, "preenchimento" + oe [a], 0, i), "preenchimento"! == n? U + = w.css (e "limite" "+ oe [a] +"Largura ",! 0, i): s + = w.css (e" limite "+ oe [a] +" Largura ",! 0, i)); retorno! R && o> = 0 && (u + = Math.max ( 0, Math.ceil (e ["deslocamento" + t [0] .toUpperCase (r "," contentEditable "], function () {w.propFix [this.toLowerCase ()] = esta}); função vt (e) {return (e.match (M) || []). join (" ")} function mt (e) {return e.getAttribute && e.getAttribute (" classe ") ||" "} function xt (e) {retornar Array.isArray (e)? e:" string "== tipo de e? e .match (M) || []: []} w.fn.extend ({addClass: função (e) {var t, n, r, i, o, a, s, u = 0; se (g ( e)) retornar this.each (function (t) {w (this) .addClass (e.call (isso, t, mt (isso)))}); if ((t = xt (e)). length) while (n = isso [u ++]) if (i = mt (n), r = 1 === n.nodeType && "" + vt (i) + "") {a = 0; enquanto (o = t [a ++ ]) r.indexOf ("" + o + "") <0 && (r + = o + ""); i! == (s = vt (r)) && n.setAttribute ("classe", s)} retorna isto}, removeClass: function (e) {var t, n, r, i, o, a, s, u = 0; se (g (e)) retornar this.each (function (t) {w (this) .removeClass ( e.call (isto, t,mt (this)))}); if (! arguments.length) retorna this.attr ("class", ""); if ((t = xt (e)). length) while (n = isso [u ++] ) if (i = mt (n), r = 1 === n.nodeType && "" + vt (i) + "") {a = 0; while (o = t [a ++]) enquanto (r.indexOf () "" + o + "")> - 1) r = r.replace ("" + o + "", ""); i! == (s = vt (r)) && n.setAttribute ("classe", s) } return this}, toggleClass: function (e, t) {var n = tipo de e, r = "string" === n || Array.isArray (e); retorno "booleano" == tipo de texto && r? t? this .addClass (e): this.removeClass (e): g (e)? this.each (função (n) {w (this) .toggleClass (e.call (isto, n, mt (isto), t), t)}): this.each (function () {var t, i, o, a; if (r) {i = 0, o = w (isto), a = xt (e); enquanto (t = a [i ++]) o.hasClass (t)? o.removeClass (t): o.addClass (t)} mais void 0! == e && "boolean"! == n || ((t = mt (this)) && J.set (isso "__className __ ", t), this.setAttribute && this.setAttribute (" classe ", t ||! 1 === e?" ": J.get (isto," __ className __ ") ||" "))})}, hasClass : function (e) {var t, n, r = 0; t = "" + e + ""; enquanto (n = isto [r ++]) if (1 === n.nodeType && ("" + vt (mt ( n)) + "") .indexOf (t)> - 1) return! 0; return! 1}}); var bt = / \ r / g; w.fn.extend ({val: function (e) { var t, n, r, i = este [0]; {if (arguments.length) retorna r = g (e), this.each (função (n) {var i; 1 === this.nodeType && (null == (i = r? e.call (isto, n, w (isto) .val ()): e)? i = "": "número" == tipoof i? i + = "": Array.isArray ( i) && (i = w.map (i, função (e) {return null == e? "": e + ""})), (t = w.valHooks [this.type] || w.valHooks [ this.nodeName.toLowerCase ()]) && "set" em t && void 0! == t.set (this, i, "value") || (isto.valor = i))}); if (i) return (t = w.valHooks [i.type] || w.valHooks [i.nodeName.toLowerCase ()]) && "get" em t && void 0! == ( n = t.get (i, "valor"))? n: "string" == typeof (n = i.value)? n.replace (bt, ""): null == n? "": n} }}), w.extend ({valHooks: {opção: {get: função (e) {var t = w.find.attr (e, "valor"); retorno nulo! = t? t: vt (w. text (e)}}}, selecione: {get: function (e) {var t, n, r, i = e.options, o = e.selectedIndex, a = "selecionar um" === e.type , s = a? null: [], u = a? o + 1: i.length; para (r = o <0? u: a? o: 0; r <u; r ++) if (((n = i [r]) selecionado || r === o) &&! n.disabled && (! n.parentNode.disabled ||! N (n.parentNode, "optgroup"))) {se (t = w (n ) .val (), a) retorna t; s.push (t)} retorna s}, set: function (e, t) {var n, r, i = e.options, o = w.makeArray (t) , a = i.length; while (a -) ((r = i [a]). selected = w.inArray (w.valHooks.option.get (r), o)> - 1) && (n = ! 0);return n || (e.selectedIndex = -1), o}}}}), w.each (["radio", "checkbox"], função () {w.valHooks [this] = {set: function ( e, t) {se (Array.isArray (t)) retornar e.checked = w.inArray (w (e) .val (), t)> - 1}}, h.checkOn || (w.valHooks [ this] .get = function (e) {return null === e.getAttribute ("valor")? "em": e.value})}), h.focusin = "onfocusin" em e; var wt = / ^ (?: focusinfocus | focusoutblur) $ /, Tt = função (e) {e.stopPropagation ()}; w.extend (evento.event, {disparador: função (t, n, i, o) {var a, s, u, l, c, p, d, h, v = [i || r], m = f.call (t, "tipo")? t.type: t, x = f.call (t, "namespace")? t.namespace.split ("."): []; se (s = h = u = i = i || r, 3! == i.nodeType && 8! == i.nodeType &&! wt. teste (m + w.event.triggered) && (m.indexOf (".")> - 1 && (m = (x = m.split (".")). shift (), x.sort ()), c = m.indexOf (":") <0 && "em "+ m, t = t [w.expando]? t: novo w.Event (m," objeto "== tipo de t && t), t.isTrigger = o? 2: 3, t.namespace = x.join ( "."), t.rnamespace = t.namespace? new RegExp ("(^ | \\.)" + x.join ("\\. (?:. * \\. |)") + "(\ \. | $) "): null, t.result = void 0, t.target || (t.target = i), n = nulo == n? [t]: w.makeArray (n, [t] ), d = w.event.special [m] || {}, o ||! d.trigger ||! 1! == d.trigger.apply (i, n))) {if (! o &&! d .noBubble &&! y (i)) {para (l = d.delegateType || m, wt.test (l + m) || (s = s.parentNode); s; s = s.parentNode) v.push ( s), u = s; u === (i.ownerDocument || r) && v.push (u.defaultView || u.parentWindow || e)} a = 0; while ((s = v [a ++]) &&! t.isPropagationStopped ()) h = s, t.type = a> 1? l: d.bindType || m, (p = (J.get (s, "eventos") || {}) [t .type] && J.get (s, "handle")) && p.apply (s, n), (p = c && s [c]) && p.apply && Y (s) && (t.result = p.apply (s, n) ,! 1 === t.result && t.preventDefault ()); return t.type = m, o || t.isDefaultPrevented () || d._default &&! 1! == d._default.apply (v.pop (), n) ||! Y (i) || c && g (i [m]) &&! y (i) && ((u = i [c]) && (i [ c] = null), w.event.triggered = m, t.isPropagationStopped () && h.addEventListener (m, Tt), i [m] (), t.isPropagationStopped () && h.removeEventListener (m, Tt), w .event.triggered = void 0, u && (i [c] = u)), t.result}}, simula: function (e, t, n) {var r = w.extend (novo w.Event, n, {type: e, isSimulated:! 0}); w.event.trigger (r, nulo, t)}}), w.fn.extend ({trigger: função (e, t) {return this.each (função () {w.event.trigger (e, t, isto)})}, triggerHandler: function (e, t) {var n = este [0]; if (n) retorna w.event.trigger (e, t , n,! 0)}}), h.focusin || w.each ({focus: "focus", blur: "focusout"}, função (e, t) {var n = função (e) {w. event.simulate (t, e.target, w.event.fix (e))}; w.event.special [t] = {setup: function () {var r = this.ownerDocument || isto, i = J.access (r, t); i || r.addEventListener (e, n,! 0), J.acesso (r, t, (i || 0) +1)}, desmontagem: function () {var r = this.ownerDocument || i = J. acesso (r, t) -1; i? J. acesso (r, t, i) :( r.removeEventListener (e, n,! 0), J.remove (r, t))}} }); var Ct = e.location, Et = Date.now (), kt = / \? /; w.parseXML = função (t) {var n; if (! t || "cadeia"! = tipo de t ) return null; try {n = (novo e.DOMParser) .parseFromString (t, "text / xml")} catch (e) {n = void 0} return n &&! n.getElementsByTagName ("parsererror"). length | | w.error ("XML inválido:" + t), n}; var St = / \ [\] $ /, Dt = / \ r? \ n / g, Nt = / ^ (?: submit | button | imagem | redefinir | arquivo) $ / i, At = / ^ (?: entrada | select | textarea | keygen) / i; função jt (e, t, n, r) {var i; if (Array.isArray (t )) w.each (t, função (t, i) {n || Sttest (e) r (e, i): jt (e + "[" + ("objeto"== typeof i && null! = i? t: "") + "]", i, n, r)}); senão se (n || "objeto"! == x (t)) r (e, t) senão para (i em t) jt (e + "[" + i + "]", t [i], n, r)} w.param = função (e, t) {var n, r = [], i = função (e, t) {var n = g (t)? t (): t; r [comprimento] = encodeURIComponent (e) + "=" + encodeURIComponent (null == n? "": n) }; if (Array.isArray (e) || e.jquery &&! w.isPlainObject (e)) w.each (e, function () {i (this.name, this.value)}); else para (n em e) jt (n, e [n], t, i); retorno r.join ("&")}, w.fn.extend ({serialize: function () {retorno w.param (this.serializeArray ( )), serializeArray: function () {retornar this.map (function () {var e = w.prop (isso, "elementos"); return e? w.makeArray (e): este}). filter (function () {var e = this.type; retorne this.name &&! w (this) .is (": disabled") && At.test (this.nodeName) &&! Nt.test (e) && (este.verificado ||! pe.test (e))}). map (função (e, t) {var n = w (isto) .val (); retorno nulo == n? nulo: Array.isArray (n)? w.map (n, função (e) {return {nome: t.name, valor: e.replace (Dt, "\ r \ n")}}): {nome: t.name, valor: n.replace (Dt, "\ r \ n")}}). Get ()}}); var qt = /% 20 / g, Lt = / #. * $ /, Ht = / ([? &]) _ = [^ &] * /, Ot = / ^ (. *?): [\ T] * ([^ \ r \ n] *) $ / gm, Pt = / ^ (?: sobre | app | app-armazenamento |. + - extensão | arquivo | res | widget): $ /, Mt = / ^ (?: GET | HEAD) $ /, Rt = / ^ \ / \ //, É = {}, Wt = {}, $ t = "* /". concat ("*"), Bt = r.createElement ("a"); Bt.href = Ct.href; função Ft (e) {função de retorno (t, n) {"string "! = typeof t && (n = t, t =" * "); var r, i = 0, o = t.toLowerCase (). corresponde (M) || []; se (g (n)) while ( r = o [i ++]) "+" === r [0]? (r = r.slice (1) || "*", (e [r] = e [r] || []). (n)) :( e [r] = e [r] || []). push (n)}} função _t (e, t, n, r) {var i = {}, o = e == = Wt; função a (s) {var u; retorno i [s] =! 0, w.each (e [s] || [], função (e, s) {var l = s (t, n, r); return "string"! = typeof l || o || i [l]? o? ! (u = l): void 0: (t.dataTypes.unshift (l), a (l), 1)}), u} return a (t.dataTypes [0]) ||! i ["* "] && a (" * ")} função zt (e, t) {var n, r, i = w.ajaxSettings.flatOptions || {}; para (n em t) void 0! == t [n] && ((i [n]? e: r || (r = {})) [n] = t [n]); retorno r && w.extend (! 0, e, r), e} função Xt (e, t , n) {var r, i, o, a, s = e.contents, u = e.dataTypes; while ("*" === u [0]) u.shift (), void 0 === r && (r = e.mimeType || t.getResponseHeader ("Content-Type")); if (r) para (i em s) if (s [i] && s [i] .test (r)) {u.unshift (i); break} if (u [0] em n) o = u [0]; sen {para (i em n) {se (! u [0] || e.converters [i + "" + u [ 0]]) {o = i; quebra} a || (a = i)} o = o || a} se (o) retornar o! == u [0] && u.unshift (o), n [o ]} função Ut (e, t, n, r) {var i, o, a, s, u, l = {}, c = e.dataTypes.slice (); if (c [1]) para (a em e.conversores) l [a.toLowerCase ()] = e.converters [a]; o = c.shift (); while (o) if (e.responseFields [o] && (n [e.responseFields [o]] = t), u && r && e.dataFilter && (t = e.dataFilter (t, e.dataType)), u = o, o = c.shift ()) if ("*" === o) o = u; ("*"! == u && u! == o) {if (! (a = l [u + "" + o] || l ["*" + o])) para (i em l) se ((s = i.split ("")) [1] === o && (a = l [u + "" + s [0]] || l ["*" + s [0]])) {! 0 == = a? a = l [i]:! 0! == l [i] && (o = s [0], c.unshift (s [1])); quebra} se (! 0! == a) if (a && e ["throws"]) t = a (t); senão tente {t = a (t)} capturar (e) {return {state: "parsererror", erro: a? e: "Nenhuma conversão de" + u + "para" + o}}} return {estado: "sucesso", dados: t}} w.extend ({ativo: 0, lastModified: {}, etag: {}, ajaxSettings: {url: Ct.href , digite: "GET", isLocal: Pt.test (Ct.protocol), global:! 0,processData:! 0, async:! 0, contentType: "aplicativo / x-www-form-urlencoded; charset = UTF-8", aceita: {"*": $ t, texto: "text / plain", html: "text / html", xml: "aplicativo / xml, texto / xml", json: "aplicativo / json, texto / javascript"}, conteúdo: {xml: / \ bxml \ b /, html: / \ bhtml /, json: / \ bjson \ b /}, responseFields: {xml: "responseXML", texto: "responseText", json: "responseJSON"}, conversores: { "* texto": string, "html texto": 0, "json texto": JSON.parse, "xml texto": w.parseXML}, flatOptions: {url: 0, contexto: 0}}, ajaxSetup: function (e, t) {return t ZT (ZT ( e, w.ajaxSettings), t): zt (w.ajaxSettings, e)}, ajaxPrefilter: Ft (Ele), ajaxTransport: Ft (Wt), Ajax: função (T, N) { "objecto" == typeof t && (n = t, t = void 0), n = n || {}; var i, o, a, s, u, l, c, f, p, d, h = w. ajaxSetup ({}, n ), g = h.context || h,y = h.context && (g.nodeType || g.jquery)? w (g): w.event, v = w.Deferred (), m = w.Callbacks ("uma vez memória"), x = h.statusCode || {}, b = {}, T = {}, C = "cancelado", E = {readyState: 0, getResponseHeader: função (e) {var t; if (c) {if (! s) {s = {}; while (t = Ot.exec (a)) s [t [1] .toLowerCase ()] = t [2]} t = s [e.toLowerCase ()]} retorno nulo == t? nulo : t}, getAllResponseHeaders: function () {retorno c? a: null}, setRequestHeader: função (e, t) {retorno null == c && (e = T [e.toLowerCase ()] = T [e.toLowerCase ( )] || e, b [e] = t), this}, overrideMimeType: function (e) {retorno nulo == c && (h.mimeType = e), este}, statusCode: function (e) {var t; if (e) se (c) E.always (e [E.status]), senão para (t em e) x [t] = [x [t], e [t]], retorne isto}, abortar: funç˜ao (e) {var t = e || C; retorno i && i.abort (t), k (0, t), isto}} se (v.promise (E), h.url = ((t || h.url || Ct.href) + ""). replace (Rt, Ct.protocol + "//"), h.type = n.method || n.digite || h.method || h.type, h.dataTypes = (h.dataType || "*"). toLowerCase (). match (M) || [""], nulo == h.crossDomain) { l = r.createElement ("a"); tente {l.href = h.url, l.href = l.href, h.crossDomain = Bt.protocol + "//" + Bt.host! = l.protocol + " //"+l.host}catch(e){h.crossDomain=!0}}if(h.data&&h.processData&&"string"!=typeof h.data&& (h.data = w.param (h.data, h.traditional)), _t (It, h, n, E), c) return E (f = w.event && h.global) && 0 == w.active ++ && w.event.trigger ("ajaxStart"), h.type = h.type.toUpperCase (), h.hasContent =! Mt.test (h.type), o = h.url.replace (Lt, ""), h.hasContent? h.data && h.processData && 0 = == (h.contentType || ""). indexOf ("aplicativo / x-www-form-urlencoded") && (h.data = h.data.replace (qt, "+")): (d = h .url.slice (o.length), h.dados && (h.processData || "string" == typeof h.data) && (o + = (kt.test (o)? "&": "?") + h.data, excluir h.data), 1 === h.cache && (o = o.replace (Ht, "$ 1"), d = (kt.test (o)? "&": "?") + "_ =" + Et +++ d) , h.url = o + d), h.ifModified && (w.lastModified [o] && E.setRequestHeader ("Se-Modificado-Desde", w.lastModified [o]), w.etag [o] && E.setRequestHeader ( "If-None-Match", w.etag [o])), (h.data && h.hasContent &&! 1! == h.contentType || n.contentType) && E.setRequestHeader ("Tipo de Conteúdo", h.contentType ), E.setRequestHeader ("Aceitar", h.dataTypes [0] && h.accepts [h.dataTypes [0]]? H.accepts [h.dataTypes [0]] + ("*"! == h.dataTypes [0]? "," + $ T + "; q = 0.01": ""): h.accepts ["*"]); para (p em h.cabeçalhos) E.setRequestHeader (p, h.headers [p]); se (h.beforeSend && (! 1 === h.beforeSend.call (g, E, h) || c)) retornar E.abort () ; if (C = "anular", m.add (h.complete), E.done (h.success), E.fail (h.error), i = _t (Wt, h, n, E)) { if (E.readyState = 1, f &&.trigger ("ajaxSend", [E, h]), c) retornar E; h.async && h.timeout> 0 && (u = e.setTimeout (function () {E.abort ( "timeout")}, h.timeout)); tente {c =! 1, i.send (b, k)} capture (e) {se (c) lançar e; k (-1, e)}} mais k (-1, "Sem transporte"); função k (t, n, r, s) {var l, p, d, b, T, C = n; c || (c =! 0, u && e.clearTimeout (u), i = void 0, a = s || "", E.readyState = t> 0? 4: 0, l = t> = 200 & t <300 || 304 === t, r && (b = Xt (h, E, r)), b = Ut (h, b, E, l), l? (h.ifModified && ((T = E.getResponseHeader ("Última modificação")) && (w.lastModified [o ] = T), (T = E.getResponseHeader ("etag")) && (w.etag [o] = T)), 204 === t || "HEAD" === h.type? C = "nocontent": 304 === t? C = "não modificado" :( C = b.state , p = b.data, l =! (d = b.error))): (d = C,! t && C || (C = "erro", t <0 && (t = 0))), E.status = t, E.statusText = (n || C) + "", l? v.resolveCom (g, [p, C, E]): v.rejectCom (g, [E, C, d]), E .statusCode (x), x = void 0, f &&.trigger (l? "ajaxSuccess": "ajaxError", [E, h, l? p: d]), m.fireCom (g, [E, C]) , f && (y.trigger ("ajaxComplete", [E, h]), - w.active || w.event.trigger ("ajaxStop")))} retorno E}, getJSON: function (e, t, n) {return w.get (e, t, n, "json")}, getScript: function (e, t) {retorno w.get (e, void 0, t, "script")}}, w .each (["get", "post"], função (e, t) {w [t] = função (e, n, r, i) {retorno g (n) && (i = i || r, r = n, n = void 0), w. ajax (w.extend ({url: e, tipo: t, dataType: i, dados: n, sucesso: r},w.isPlainObject (e) && e))}}), w._evalUrl = function (e) {retornar w.ajax ({url: e, tipo: "GET", dataType: "script", cache:! 0, assíncrono :! 1, global:! 1, "lança":! 0})}, w.fn.extend ({wrapAll: function (e) {var; retorne isto [0] && (g (e) && (e = e.call (this [0])), t = w (e, este [0] proprietárioDocument) .eq (0) .clone (! 0), this [0] .parentNode && t.insertBefore (este [0] ), t.map (function () {var e = this; while (e.firstElementChild) e = e.firstElementChild; retorna e}). append (this)), este}, wrapInner: function (e) {retorno g (e)? this.each (função (t) {w (this) .wrapInner (e.call (isto, t))}): this.each (function () {var t = w (isto), n = t.contents (); n.length? n.wrapAll (e): t.append (e)})}, wrap: função (e) {var t = g (e); retorne this.each (função (n ) {w (this) .wrapAll (t? e.call (isto, n): e)})}, desembrulhe: function (e) {retorne this.parent (e) .not ("body"). function () {w (isso).replaceWith (this.childNodes)}), this}}), w.expr.pseudos.hidden = função (e) {return! w.expr.pseudos.visible (e)}, w.expr.pseudos.visible = function (e) {return !! (e.offsetWidth || e.offsetHeight || e.getClientRects (). length)}, w.ajaxSettings.xhr = function () {tentar {retornar novo e.XMLHttpRequest} catch (e) {}}; var Vt = {0: 200,1223: 204}, Gt = w.ajaxSettings.xhr (); h.cors = !! Gt && "withCredentials" em Gt, h.ajax = Gt = !! Gt, w.ajaxTransport (função (t) {var n, r; if (h.cors || Gt &&! t.crossDomain) return {send: função (i, o) {var a, s = t.xhr (); (s.open (t.type, t.url, t.async, t.username, t.password), t.xhrFields) para (a em t.xhrFields) s [a] = t.xhrFields [a]; t.mimeType && s.overrideMimeType && s.overrideMimeType (t.mimeType), t.crossDomain || i ["X-Requested-With"] || (i ["X-Requested-With"] = "XMLHttpRequest"); em i) s.setRequestHeader (a, i [a]);n = função (e) {função return () {n && (n = r = s.onload = s.onerror = s.onabort = s.ontimeout = s.onreadystatechange = null, "abortar" === e? s. abort (): "error" === e? "numero"! = tipo de s.status? o (0, "erro"): o (s.status, s.statusText): o (Vt [s.status] || s.status, s.statusText, "texto"! == (s.responseType || "texto") || "string"! = tipo de s.responseText? {binary: s.response}: {texto: s .responseText}, s.getAllResponseHeaders ()))}}, s.onload = n (), r = s.onerror = s.ontimeout = n ("erro"), void 0! == s.onabort? s. onabort = r: s.onreadystatechange = function () {4 === s.readyState && e.setTimeout (function () {n && r ()})}, n = n ("abortar"); tentar {s.send (t. hasContent && t.data || null)} catch (e) {se (n) lançar e}}, abort: function () {n && n ()}}}), w.ajaxPrefilter (function (e) {e.crossDomain && (e .contents.script =! 1)}), w.ajaxSetup ({aceita: {script: "texto / javascript, aplicativo / javascript, aplicativo / ecmascript, aplicativo / x-ecmascript"}, conteúdo: script {script: / \ b (?: java | ecma) \ b /}, conversores: {"script de texto": function (e) {retorno w.globalEval (e), e}}}), w.ajaxPrefilter ("script", função (e) {void 0 === e.cache && (e .cache =! 1), e.crossDomain && (e.type = "GET")}), w.ajaxTransport ("script", função (e) {if (e.crossDomain) {var t, n; return {enviar : function (i, o) {t = w ("<script>"). prop ({charset: e.scriptCharset, src: e.url}) em ("erro de carga", n = função (e) { t.remove (), n = null, e&& ("error" === e.type? 404: 200, e.type)}), r.head.appendChild (t [0])}, abort: function ( ) {n && n ()}}}}; var Yt = [], Qt = / (=) \? (? = & | $) | \? \? /; w.ajaxSetup ({jsonp: "retorno de chamada", jsonpCallback: function () {var e = Yt.pop () || w.expando + "_" + Et ++; retorna isto [e] =! 0, e}}), w.ajaxPrefilter ("json jsonp", função (t, n, r) {var i, o, a, s =! 1 ! == t.jsonp && (Qt.test (t.url)? "url": "string" == typeof t.data && 0 === (t.contentType || ""). indexOf ("aplicativo / x-www -form-urlencoded ") && Qt.test (t.data) &&" data "); if (s ||" jsonp "=== t.dataTypes [0]) retornará i = t.jsonpCallback = g (t.jsonpCallback t.jsonpCallback (): t.jsonpCallback, s? t [s] = t [s] .replace (Qt, "$ 1" + i):! 1! == t.jsonp && (t.url + = (kt .test (t.url)? "&": "?") + t.jsonp + "=" + i), t.conversores ["script json"] = function () {retornar um || w.error (i + "não foi chamado"), a [0]}, t.dataTypes [0] = "json", o = e [i], e [i] = função () {a = argumentos}, r.always (função () {void 0 === o? w (e) .removeProp (i): e [i] = o, t [i] && (t.jsonpCallback = n.jsonpCallback, Yt.push (i)), a && g (o) && o (a [0]), a = o = void 0}), "script"}), h.createHTMLDocument = function () {var e = r.implementation.createHTMLDocument (""). body; retorno e.innerHTML = "<form> </ form> <form> </ form>", 2 === e.childNodes.length} (), w.parseHTML = função (e, t, n) {if ("string"! = typeof e) return []; "booleano" == tipo de t && (n = t, t =! 1); var i , o, a; return t || (h.createHTMLDocument? ((i = (t = r.implementation.createHTMLDocument ("")). createElement ("base")). href = r.location.href, t. head.appendChild (i)): t = r), o = A.exec (e), a =! n && [], o? [t.createElement (o [1])] :( o = xe ([e ], t, a), a && a.length && w (a) .remove (), w.merge ([], o.childNodes))}, w.fn.load = função (e, t, n) {var r, i, o, a = isto, s = e.indexOf (""); return s> -1 &&(r = vt (e.slice (s)), e = e.slice (0, s)), g (t)? (n = t, t = void 0): t && "objeto" == tipo de t && ( i = "POST"), a.length> 0 && w.ajax ({url: e, tipo: i || "GET", dataType: "html", dados: t}). done (função (e) {o = argumentos, a.html (r? w ("<div>"). append (w.paraHTML (e)). encontrar (r): e)}). always (n && function (e, t) {a.each ( function () {n.apply (isto, o || [e.responseText, t, e])})}), este}, w.each (["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError "," ajaxSuccess "," ajaxSend "], função (e, t) {w.fn [t] = função (e) {retornar this.on (t, e)}}), w.expr.pseudos.animated = function (e) {return w.grep (w.timers, função (t) {return e === t.elem}). comprimento}, w.offset = {setOffset: function (e, t, n) { var r, i, o, a, s, u, l, c = w.css (e, "posição"), f = w (e), p = {}; "estática" === c && (e. estilo.position = "relative"), s = f.offset (), o = w.css (e, "topo"), u = w.css (e, "esquerda"), (l = ("absoluto" == = c || "fixo" === c) && (o + u) .indexOf ("auto")> - 1)? (a = (r = f.position ()). topo, i = r.left ): (a = parseFloat (o) || 0, i = parseFloat (u) || 0), g (t) && (t = t.call (e, n, w.extend ({}, s)) ), null! = t.top && (p.top = t.top-s.top + a), nulo! = t.left && (p.left = t.left-s.left + i), "using" em t.us.using.call (e, p): f.css (p)}}, w.fn.extend ({deslocamento: função (e) {if (arguments.length) return void 0 === e? isto: this.each (function (t) {w.offset.setOffset (isto, e, t)}); var t, n, r = isto [0]; if (r) retorna r.getClientRects (). ? (t = r.getBoundingClientRect (), n = r.ownerDocument.defaultView, {topo: t.top + n.pageYOffset, esquerda: t.left + n.páginaXOffset}): {topo: 0, esquerda: 0} }, position: function () {se (isto [0]) {var e, t, n, r = isto [0], i = {topo: 0, esquerda: 0}; if ("fixo "=== w.css (r," posição ")) t = r.getBoundingClientRect (); else {t = isto.offset (), n = r.ownerDocument, e = r.offsetParent || n.documentElement ; while (e && (e === n.body || e === n.documentElement) && "estático" === w.css (e, "posição")) e = e.parentNode; e && e! == r && 1 === e.nodeType && ((i = w (e) .offset ()) .superior = = w.css (e, "borderTopWidth",! 0), i.left + = w.css (e, "borderLeftWidth" ,! 0))} return {top: t.top-i.top-w.css (r, "marginTop",! 0), à esquerda: t.left-i.left-w.css (r, "marginLeft ",! 0)}}}, offsetParent: function () {retornar this.map (function () {var e = this.offsetParent; while (e &&" static "=== w.css (e," posição ") ) e = e.offsetParent; return e || be})}}), w.each ({scrollLeft: "pageXOffset", scrollTop: "pageJOffset"}, função (e, t) {var n = "pageYOffset" = == t; w.fn [e] = função (r) {retorno z (isto, função (e, r, i) {var o; se (y (e)? o = e: 9 === e.nodeType && (o = e. defaultView), void 0 === i) retorna o? o [t]: e [r]; o? o.scrollTo (n? o.pageXOffset: i, n? i: o.pageYOffset): e [r] = i}, e, r, arguments.length)}}), w.each (["top", "left"], função (e, t) {w.cssHooks [t] = _e (h.pixelPosition, função (e, n) {se (n) retorna n = Fe (e, t), We.test (n)? w (e) .position () [t] + "px": n})}), w.each ({altura: "altura", largura: "largura"}, função (e, t) {w.each ({preenchimento: "interior" + e, conteúdo: t, "": "exterior" + e }, function (n, r) {w.fn [r] = função (i, o) {var a = argumentos.length && (n || "booleano"! = tipo de i), s = n || (! 0 === i ||! 0 === o? "margin": "border"); retorno z (isso, função (t, n, i) {var o; retorno y (t)? 0 === r .indexOf ("outer")? t ["interior" + e]: t.document.documentElement ["cliente "+ e]: 9 === t.nodeType? (o = t.documentElement, Math.max (t.body [" rolar "+ e], o [" rolar "+ e], t.body [" offset "+ e], o [" offset "+ e], o [" cliente "+ e])): void 0 === i? w.css (t, n, s): w.style (t, n, i, s)}, t, um i:? vazio 0, a)}})}), w.each ( "foco borrão focusIn focusOut redimensionar rolar clique em alterar dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave selecionar enviar keypress keydown keyup contextmenu ".split (" "), função (e, t) {w.fn [t] = função (e, n) {retorno arguments.length> 0? this.on (t, nulo, e, n) : this.trigger (t)}}), w.fn.extend ({hover: function (e, t) {retornar this.mouseenter (e) .mouseleave (t || e)}}), w.fn. estender ({bind: function (e, t, n) {retornar this.on (e, nulo, t, n)}, desvincular: function (e, t) {retornar this.off (e, nulo, t)} , delegate: function (e, t, n, r) {retornar this.on (t, e, n, r)}, undelegate: function (e, t,n) {return 1 === arguments.length? this.off (e, "**"): this.off (t, e || "**", n)}}), w.proxy = função ( e, t) {var n, r, i; se ("string" == typeof t && (n = e [t], t = e, e = n), g (e)) retorna r = o.call ( argumentos, 2), i = function () {return e.apply (t || isto, r.concat (o.call (argumentos)))}, i.guid = e.guid = e.guid || w. guid ++, i}, w.holdReady = função (e) {e? w.readyWait ++: w.ready (! 0)}, w.isArray = Array.isArray, w.parseJSON = JSON.parse, w.nodeName = N , w.isFunction = g, w.isWindow = y, w.camelCase = G, w.type = x, w.now = Date.now, w.isNumeric = função (e) {var t = w.type (e ); return ("número" === t || "string" === t) &&! isNaN (e-parseFloat (e))}, "função" == typeof define && define.amd && define ("jquery", [] , function () {return w}); var Jt = e.jQuery, Kt = e. $; return w.noConflict = função (t) {return e. $ === w && (e. $ = Kt), t && e .jQuery === w && (e.jQuery = Jt), w}, t || (e.jQuery = e. $ = w), w});